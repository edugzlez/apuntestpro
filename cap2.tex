\cleardoublepage
\chapter{Semántica operacional}
						
$\\$

En el anterior capítulo hemos visto cómo dar un valor semántico al lenguaje While mediante el punto de vista de la semántica denotacional. Centrémonos ahora en la semántica operacional. La distinción fundamental que hacíamos de este enfoque es la siguiente:
\begin{itemize}
    \item Semántica operacional \textit{natural}, que describe cómo se han obtenido los resultados generales de las ejecuciones.
    \item Semántica operacional \textit{estructural}, que describe cómo se ha obtenido cada paso en la ejecución.
\end{itemize}
Para ambos tipos de semántica operacional, el valor semántico de cada expresión será especificado por un \textit{sistema de transiciones}, compuesto de dos configuraciones distintas:
\begin{itemize}
    \item[] $\langle S, s\rangle$, que denota que la expresión $S$ se ejecutará desde el estado $s$.
    \item[] $s$, que denota un estado terminal. Las \textit{configuraciones terminales} tendrán esta forma.
\end{itemize}
Finalmente, es necesaria una \textit{relación de transición} que describa cómo tiene lugar la ejecución. La diferencia entre las dos semánticas se encuentra principalmente en ésta. De hecho, veremos que ambos tipos de semántica son, en cierto sentido, equivalentes.

\section{Semántica operacional natural}


\subsection{Sistema de transiciones}

La relación de transición $\langle S, s\rangle \rightarrow s'$ se puede leer como que, la ejecución de $S$ desde el estado $s$ terminará y el nuevo estado será $s'$. Está determinada por las siguientes reglas\footnote{Nótese que las variables $S_1, S_2, s, s', s''$, etc. quedan fijadas en la premisa pero libres en la consecuencia.}:  


\begin{sist*}[$\nn{While}_\nn{ns}$]\mbox{}
\begin{itemize}
    \item[] $[\text{ass}_{\text{ns}}]$

        \begin{center}
              \centerAlignProof
              \quad
              \centerAlignProof
                \AxiomC{}
                \UnaryInfC{ $\langle x:= a, s\rangle \rightarrow s[x\mapsto \fc{A}{a}s]$}
              \DisplayProof
        \end{center}

    \item[] $[\text{skip}_{\text{ns}}]$ 
        \begin{center}
              \centerAlignProof
              \quad
              \centerAlignProof
                \AxiomC{}
                \UnaryInfC{$\la{\n{skip}}{s}\rightarrow s$}
                  \DisplayProof
        \end{center}

    \item[][$\text{comp}_{\text{ns}}$]
        \begin{center}
              \centerAlignProof
                
              \quad
              \centerAlignProof
                \AxiomC{$\la{S_1}{s} \to s'$}
                \AxiomC{$\la{S_2}{s'} \to s''$}
                \BinaryInfC{$\la{S_1; S_2}{s} \to s''$}
              \DisplayProof
        \end{center}
\newpage
\item[][$\text{if}^{\text{tt}}_{\text{ns}}$]


\begin{center}
      \centerAlignProof
        
      \quad
      \centerAlignProof
        \AxiomC{$\la{S_1}{s} \to s'$}
        \UnaryInfC{$\la{\n{if}\ b\ \n{then}\ S_1\ \n{else}\ S_2}{s} \to s'$}
      \DisplayProof
      \quad
      \centerAlignProof
        $\text{ si }\fc{B}{b}s = \mathbf{tt}$
\end{center}
\item[] [$\text{if}^{\text{ff}}_{\text{ns}}$]

\begin{center}
      \centerAlignProof
       
      \quad
      \centerAlignProof
        \AxiomC{$\la{S_2}{s} \to s'$}
        \UnaryInfC{$\la{\n{if}\ b\ \n{then}\ S_1\ \n{else}\ S_2}{s} \to s'$}
      \DisplayProof
      \quad
      \centerAlignProof
        $\text{ si }\fc{B}{b}s = \mathbf{ff}$
\end{center}
\item[][$\text{while}^{\text{tt}}_{\text{ns}}$]

\begin{center}
      \centerAlignProof
        
      \quad
      \centerAlignProof
        \AxiomC{$\la{S}{s} \to s'$}
        \AxiomC{$\la{\n{while}\ b\ \n{do}\ S}{s'} \to s''$}
        \BinaryInfC{$\la{\n{while}\ b\ \n{do}\ S}{s} \to s''$}
      \DisplayProof
      \quad
      \centerAlignProof
        $\text{ si }\fc{B}{b}s = \mathbf{tt}$
\end{center}
\item[] [$\text{while}^{\text{ff}}_{\text{ns}}$]

\begin{center}
      \centerAlignProof
       
      \quad
      \centerAlignProof
        \AxiomC{}
        \UnaryInfC{$\la{\n{while}\ b\ \n{do}\ S}{s} \to s$}
      \DisplayProof
      \quad
      \centerAlignProof
        $\text{ si }\fc{B}{b}s = \mathbf{ff}$
\end{center}
\end{itemize}
\end{sist*}

Aclaremos un poco la terminología:

\begin{definition}
Una \textit{regla} en general tiene la forma general
\begin{center}
      \centerAlignProof
       
      \quad
      \centerAlignProof
        \AxiomC{$\la{S_1}{s_1}\rightarrow s'_1 \dots \la{S_n}{s_n}\rightarrow s'_n $}
    \UnaryInfC{$\la{S}{s}\rightarrow s'$}
      \DisplayProof
      \quad
      \centerAlignProof
    $\text{ si } \varphi$
\end{center}
donde los términos que aparecen encima y bajo la línea son, respectivamente, las \textit{premisas} y la \textit{conlusión}, y donde $\varphi$ es la \textit{condición}. Cuando empleamos las reglas anteriores para obtener una transición $\la{S}{s}\rightarrow s'$, obtenemos un \textit{árbol de derivación}. Una regla sin premisas se llama \textit{axioma}.
\end{definition}

Consideremos el problema de construir un árbol de derivación para una expresión $S$ y un estado $s$. El método general consiste en partir de la `raíz' y encontrar las `hojas', es decir, el paso inicial consiste en buscar una regla de modo que su conclusión tenga la ejecución $\la{S}{s}$ en su parte izquierda. Los pasos inductivos son:
\begin{itemize}
    \item Si la regla encontrada es un axioma, entonces podemos determinar el estado terminal y terminamos.
    \item Si la regla encontrada no es un axioma, entonces el siguiente paso consiste en buscar un árbol de derivación para sus premisas. 
\end{itemize}
Nótese que, en cada paso, las condiciones para aplicar cada regla tienen que ser verificadas. En el futuro demostraremos algo que parece falso a primera vista: que en el lenguaje While hay a lo sumo un árbol de derivación posible para cada ejecución $\la{S}{s}$.


\begin{definition}
Decimos que una ejecución de la expresión $S$ desde el estado $s$, $\la{S}{s}$, \textit{termina} si existe un estado $s'$ tal que $\la{S}{s}\rightarrow s'$. Si tal estado no existe entonces decimos que la ejecución \textit{cicla}. Para una expresión $S$, decimos que \textit{siempre termina} si $\la{S}{s}$ termina para cada elección de $s$ y que \textit{siempre cicla} si $\la{S}{s}$ cicla para cada elección de $s$.
\end{definition}

\begin{example}
Podemos tratar de determinar si las siguientes expresiones terminan o ciclan siempre:
\begin{enumerate}
    \item $\n{while} \, \neg(\n{x}=1) \, \n{do} \, (\n{y} := \n{y} \times \n{x}; \n{x} := \n{x} - 1)$.
    \item $\n{while} \, 1 \leq \n{x} \, \n{do} \, (\n{y} := \n{y} \times \n{x}; \n{x} := \n{x} - 1)$.
    \item $\n{while true do skip}$.
\end{enumerate}
La primera para siempre, pues si se inicializa
\end{example}

\subsection{Propiedades}

El sistema de transición nos da un entorno en el que estudiar las propiedades de las expresiones. Veamos a continuación una definición precisa de un concepto que introdujimos al final de la introducción:
\begin{definition}
Dos expresiones $S_1, S_2$ se dicen \textit{semánticamente equivalentes} si para cada par $s, s' \in \mathbf{State}$, 
$$\la{S_1}{s}\rightarrow s' \text{ si y solo si } \la{S_2}{s}\rightarrow s'.$$
\end{definition}

\begin{lema}
\normalfont $\n{while } b \n{ do } S$ \textit{es semánticamente equivalente a} $\n{if } b \n{ then } (S; \n{while } b \n{ do } S)\n{ else skip}$.
\end{lema}
\begin{proof}
Dividimos la prueba en dos implicaciones:


\noindent\textit{Parte 1.} Supongamos que se cumple $\la{\n{while } b \n{ do } S}{s}\rightarrow s''$. Entonces existe un árbol de derivación para él, $T$. $T$ puede tener dos formas en función de la regla que hayamos aplicado: o bien hemos aplicado la regla o el axioma [$\text{while}^{\text{ff}}_{\text{ns}}$]. Veamos cada caso:
\\

\noindent$(a)$ Si hemos aplicado la regla [$\text{while}^{\text{tt}}_{\text{ns}}$], $T$ es de la forma:
\begin{center}
      \centerAlignProof
      \quad
      \centerAlignProof
      \AxiomC{$\dots$}
      \UnaryInfC{$\la{S}{s}\rightarrow s'$}
      \AxiomC{$\dots$}
      \UnaryInfC{$\la{\n{while}\ b\ \n{do}\ S}{s'} \to s''$}
    \BinaryInfC{$\la{\n{while } b \n{ do } S}{s}\rightarrow s''$}[$\text{while}^{\text{tt}}_{\text{ns}}$]
      \DisplayProof
      \quad
      \centerAlignProof
      \end{center}

con $\fc{B}{b}s = \mathbf{tt}$. Ahora bien, notemos que:
\begin{center}
      \centerAlignProof
      \quad
      \centerAlignProof
      \AxiomC{$\dots$}
      \UnaryInfC{$\la{S}{s}\rightarrow s'$}
      \AxiomC{$\dots$}
      \UnaryInfC{$\la{\n{while}\ b\ \n{do}\ S}{s'} \to s''$}
    \BinaryInfC{$\la{S;\n{while } b \n{ do } S}{s}\rightarrow s''$}$[\text{comp}_{\text{ns}}]$
      \DisplayProof
      \quad
      \centerAlignProof
      \end{center}
Usando que $\fc{B}{b}s = \mathbf{tt}$, podemos aplicar:
\begin{center}
      \centerAlignProof
      \quad
      \centerAlignProof
    \AxiomC{$\la{S;\n{while } b \n{ do } S}{s}\rightarrow s''$}
    \UnaryInfC{$\la{\n{if}\ b\ \n{then}\ (S;\n{while } b \n{ do } S)\ \n{else}\ \n{skip}}{s} \to s''$}[$\text{if}^{\text{ff}}_{\text{ns}}$]
      \DisplayProof
      \quad
      \centerAlignProof
      \end{center}
Y por tanto, $\la{\n{if}\ b\ \n{then}\ (S;\n{while } b \n{ do } S)\ \n{else}\ \n{skip}}{s} \to s''$.
\\

\noindent $(b)$ Si hemos aplicado la regla  [$\text{while}^{\text{ff}}_{\text{ns}}$], $T$ es de la forma:
\begin{center}
      \centerAlignProof
       
      \quad
      \centerAlignProof
        \AxiomC{}
        \UnaryInfC{$\la{\n{while}\ b\ \n{do}\ S}{s} \to s$}
      \DisplayProof
      \quad
      \centerAlignProof
\end{center}
es decir, necesariamente $s=s''$ y $\fc{B}{b}s = \mathbf{ff}$. Usando el axioma $[\text{skip}_{\text{ns}}]$, directamente obtenemos que 
\begin{center}
      \centerAlignProof
       
      \quad
      \centerAlignProof
        \AxiomC{}
        \UnaryInfC{$\la{\n{skip}}{s}\rightarrow s''$}$[\text{skip}_{\text{ns}}]$
      \DisplayProof
      \quad
      \centerAlignProof
\end{center}
Pero entonces, 
\begin{center}
      \centerAlignProof
      \quad
      \centerAlignProof
        \AxiomC{$\la{\n{while}\ b\ \n{do}\ S}{s} \to s$}
        \AxiomC{$\la{\n{skip}}{s}\rightarrow s''$}
        \BinaryInfC{$\la{\n{if}\ b\ \n{then}\ (S;\n{while } b \n{ do } S)\ \n{else}\ \n{skip}}{s} \to s''$}[$\text{if}^{\text{ff}}_{\text{ns}}$]
      \DisplayProof
      \quad
      \centerAlignProof
\end{center}
y por tanto obtenemos el resultado.
\\

\noindent\textit{Parte 2.} Supongamos ahora que se cumple $\la{\n{if}\ b\ \n{then}\ (S;\n{while } b \n{ do } S)\ \n{else}\ \n{skip}}{s} \to s''$. Entonces, tenemos un árbol de derivación $T$ y, de nuevo, podemos distinguir qué forma tendrá según las reglas que hayamos aplicado:
\\

\noindent $(a)$ Si hemos aplicado la regla [$\text{if}^{\text{tt}}_{\text{ns}}$], $T$ es de la forma:
\begin{center}
      \centerAlignProof
        
      \quad
      \centerAlignProof
      \AxiomC{$\dots$}
        \UnaryInfC{$\la{S; \n{while } b \n{ do } s}{s} \to s''$}
        \UnaryInfC{$\la{\n{if}\ b\ \n{then}\ (S;\n{while } b \n{ do } S)\ \n{else}\ \n{skip}}{s} \to s''$}[$\text{if}^{\text{tt}}_{\text{ns}}$]
      \DisplayProof
      \quad
      \centerAlignProof
\end{center}
y con $\fc{B}{b}s = \mathbf{tt}$. Ahora bien, solo hemos podido obtener la premisa anterior mediante $[\text{comp}_{\text{ns}}]$, por tener una expresión de la forma $S_1; S_2$ en la ejecución. Entonces deducimos que $T$ es:
\begin{center}
      \centerAlignProof
      \quad
      \centerAlignProof
        \AxiomC{$\dots$}
        \UnaryInfC{$\la{S}{s}\rightarrow s'$}
        \AxiomC{$\dots$}
        \UnaryInfC{$\la{\n{while } b \n{ do } S}{s'}\rightarrow s''$}
        \BinaryInfC{$\la{S; \n{while } b \n{ do } s}{s} \to s''$}[$\text{comp}_{\text{ns}}$]
      \DisplayProof
      \quad
      \centerAlignProof
\end{center}
Pero entonces notemos que, usando la hipótesis $\fc{B}{b}s = \mathbf{tt}$:
\begin{center}
      \centerAlignProof
      \quad
      \centerAlignProof
        \AxiomC{$\dots$}
        \UnaryInfC{$\la{S}{s}\rightarrow s'$}
        \AxiomC{$\dots$}
        \UnaryInfC{$\la{\n{while } b \n{ do } S}{s'}\rightarrow s''$}
        \BinaryInfC{$\la{\n{while}\ b\ \n{do}\ S}{s} \to s''$}[$\text{while}^{\text{tt}}_{\text{ns}}$]
      \DisplayProof
      \quad
      \centerAlignProof
\end{center}
y obtenemos el resultado.
\\

\noindent $(b)$ Si hemos usado la regla [$\text{if}^{\text{ff}}_{\text{ns}}$], deducimos que $\fc{B}{b}s = \mathbf{ff}$ y que por tanto tenemos un árbol de derivación para $\la{\n{skip}}{s}\rightarrow s''$ y, por tanto, que $s=s''$. Pero usando  [$\text{while}^{\text{ff}}_{\text{ns}}$], tenemos el resultado (el razonamiento ha sido análogo al apartado $(b)$ de la Parte 1).

\end{proof}



\begin{example}
Veamos que $S_1; (S_2; S_3)$ y $(S_1; S_2); S_3$ son semánticamente equivalentes. Si suponemos que $\la{S_1; (S_2; S_3)}{s}\rightarrow s'$, entonces es porque en su árbol de derivación hemos empleado [$\text{comp}_{\text{ns}}$] a las premisas $\la{S_1}{s}\rightarrow s''$ y $\la{S_2;S_3}{s''}\rightarrow s'$. A su vez, la segunda premisa proviene del mismo modo de las premisas $\la{S_2}{s''}\rightarrow t$ y $\la{S_3}{t}\rightarrow s'$. Es decir, tenemos las siguientes hojas:
\begin{itemize}
    \item[(a)] $\la{S_1}{s}\rightarrow s''$.
    \item[(b)] $\la{S_2}{s''}\rightarrow t$.
    \item[(c)] $\la{S_3}{t}\rightarrow s'$.
\end{itemize}
Ahora, combinando (a) y (b) con [$\text{comp}_{\text{ns}}$], obtenemos $\la{S_1;S_2}{s}\rightarrow t$ y, combinando esto con (c) de la misma forma, obtenemos que $\la{(S_1; S_2);S_3}{s}\rightarrow s'$, como queríamos ver. La otra implicación es análoga.

Notemos, por otro lado, que en general $S_1;S_2$ y $S_2; S_1$ no son semánticamente equivalentes: si tratásemos de hacer lo mismo que antes, obtendríamos las hojas $\la{S_1}{s}\rightarrow s''$ y $\la{S_2}{s''}\rightarrow s'$ por un lado y $\la{S_2}{s}\rightarrow s''$ y $\la{S_1}{s''}\rightarrow s'$ por otro, y en general no hay forma de combinar cada par de premisas para obtener la conclusión deseada.
\end{example}
\\


\begin{example}
Podemos expandir el sistema $\text{While}_\text{ns}$ el siguiente modo: añadimos dos reglas que permitan dar una semántica de la expresión $\n{for }x:= a_1 \n{ to } a_2\n{ do }S$, es decir, 
\begin{itemize}
    \item[] 
\begin{center}
      \centerAlignProof
      [$\text{for}_{\text{ns}}^{\text{tt}}$]
      \quad
      \centerAlignProof
        \AxiomC{$\la{x:= a_1;S}{s}\rightarrow s'$}
        \AxiomC{$\la{\n{for } \n{x}:= \n{x}+\n{1 to } a_2 \n{ do }S}{s'}\to s''$}
        \BinaryInfC{$\la{\n{for } \n{x}:= a_1\n{ to } a_2 \n{ do }S}{s}\to s''$}
        \DisplayProof
      \quad
      \centerAlignProof
        $\text{ si }\fc{B}{a_1\leq a_2}s = \mathbf{tt}$
\end{center}
 \item[] 
\begin{center}
      \centerAlignProof
      [$\text{for}_{\text{ns}}^{\text{ff}}$]
      \quad
      \centerAlignProof
        \AxiomC{}
        \UnaryInfC{$\la{\n{for } \n{x}:= a_1\n{ to } a_2 \n{ do }S}{s}\to s[\n{x}\mapsto \fc{A}{a_1}]s$}
        \DisplayProof
      \quad
      \centerAlignProof
        $\text{ si }\fc{B}{a_1\leq a_2}s = \mathbf{ff}$
\end{center}
\end{itemize}
Pero debemos tener un especial cuidado con este tipo de reglas, por ejemplo, podemos descuidar que en $a_1$ aparezca la variable $\n{y}$, a saber, que $a_1$ contenga $\n{y} + 3$, y que por otro lado en $S$ tengamos $\n{y}=5$. Del mismo modo, podríamos tener que la variable $\n{x}$ ya aparece del mismo modo como $\n{x} = 4$, por ejemplo. Si $\n{x}$ apareciera en $a_2$ entonces también tendríamos este problema.
\end{example}
\\ \\

Aunque no lo demostraremos, se puede observar que el sistema $\text{While}_\text{ns}$ es \textit{Turing-completo}, es decir, en él podemos simular cualquier computación posible en una máquina de Turing. Por tanto, se podía pensar que podemos introducir reglas para ciertas expresiones en función de su correlato en $\text{While}_\text{ns}$ (que existe, por lo anterior). Sin embargo, si quisiéramos introducir $\n{for }x:= a_1 \n{ to } a_2\n{ do }S$ como un bucle $\n{while ... do ...}$, acabaríamos teniendo apariciones de $\n{while ... do ...}$ en las reglas asociadas a $\n{for }x:= a_1 \n{ to } a_2\n{ do }S$, lo que difiere de la semántica operacional que hemos visto hasta ahora.
\\

\begin{example}
Podríamos extender el lenguaje While con dos reglas para la expresión $\n{repeat } S \n{ until } b$:
\begin{itemize}
    \item[] 
\begin{center}
      \centerAlignProof
      [$\text{repeat}_{\text{ns}}^{\text{tt}}$]
      \quad
      \centerAlignProof
        \AxiomC{$\la{S}{s}\rightarrow s'$}
        \UnaryInfC{$\la{\n{repeat } S \n{ until } b}{s}\rightarrow s'$}
        \DisplayProof
      \quad
      \centerAlignProof
        $\text{ si }\fc{B}{b}s' = \mathbf{tt}$
\end{center}
    \item[] 
\begin{center}
      \centerAlignProof
      [$\text{repeat}_{\text{ns}}^{\text{ff}}$]
      \quad
      \centerAlignProof
        \AxiomC{$\la{S}{s}\rightarrow s'$}
        \AxiomC{$\la{\n{repeat } S \n{ until } b}{s'}\rightarrow s''$}
        \BinaryInfC{$\la{\n{repeat } S \n{ until } b}{s}\rightarrow s''$}
        \DisplayProof
      \quad
      \centerAlignProof
        $\text{ si }\fc{B}{b}s' = \mathbf{ff}$
\end{center}
\end{itemize}
\end{example}
\\

\begin{prop}
$\n{repeat } S \n{ until } b$ es semánticamente equivalente a $S; \n{if } b \n{ then skip else } (\n{repeat } S \n{ until } b)$.
\end{prop}
\begin{proof}

\noindent\textit{Parte 1.} Supongamos que $\la{\n{repeat } S \n{ until } b}{s}\rightarrow s'$. Solo tenemos las siguientes posibilidades:
\\

\noindent\textit{(a)} Si hemos aplicado la regla [$\text{repeat}_{\text{ns}}^{\text{tt}}$], tenemos:
\begin{center}
      \centerAlignProof
      [$\text{repeat}_{\text{ns}}^{\text{tt}}$]
      \quad
      \centerAlignProof
        \AxiomC{$\la{S}{s}\rightarrow s'$}
        \UnaryInfC{$\la{\n{repeat } S \n{ until } b}{s}\rightarrow s'$}
        \DisplayProof
      \quad
      \centerAlignProof
        $\text{ si }\fc{B}{b}s' = \mathbf{tt}$
\end{center}
Ahora bien, por otro lado, podemos aplicar el axioma [$\text{skip}_{\text{ns}}$] para obtener directamente que $\la{\n{skip}}{s'}\rightarrow s'$. Ahora, como $\text{ si }\fc{B}{b}s' = \mathbf{tt}$, podemos aplicar la regla [$\text{if}^{\text{tt}}_{\text{ns}}$]:
\begin{center}
      \centerAlignProof
      \quad
      \centerAlignProof
        \AxiomC{$\la{\n{skip}}{s'}\rightarrow s'$}
        \UnaryInfC{$\la{\n{if}\ b\ \n{then skip else}\ (\n{repeat } S \n{ until } b)}{s'} \to s'$}[$\text{if}^{\text{tt}}_{\text{ns}}$]
      \DisplayProof
      \quad
      \centerAlignProof
\end{center}
Y, entonces, 
        \begin{center}
              \centerAlignProof
              \quad
              \centerAlignProof
                \AxiomC{$\la{S}{s} \to s'$}
                \AxiomC{$\la{\n{if}\ b\ \n{then skip else}\ (\n{repeat } S \n{ until } b)}{s'} \to s'$}
                \BinaryInfC{$\la{S; \n{if } b \n{ then skip else } (\n{repeat } S \n{ until } b)}{s} \to s'$}[$\text{comp}_{\text{ns}}$]
              \DisplayProof
        \end{center}
Luego obtenemos el resultado.
\\

\noindent\textit{(b)} Si hemos aplicado la regla [$\text{repeat}_{\text{ns}}^{\text{ff}}$], tenemos:
\begin{center}
      \centerAlignProof
      [$\text{repeat}_{\text{ns}}^{\text{ff}}$]
      \quad
      \centerAlignProof
        \AxiomC{$\la{S}{s}\rightarrow s''$}
        \AxiomC{$\la{\n{repeat } S \n{ until } b}{s''}\rightarrow s'$}
        \BinaryInfC{$\la{\n{repeat } S \n{ until } b}{s}\rightarrow s'$}
        \DisplayProof
      \quad
      \centerAlignProof
        $\text{ si }\fc{B}{b}s' = \mathbf{ff}$
\end{center}
Ahora, usando que $\text{ si }\fc{B}{b}s' = \mathbf{ff}$, 
\begin{center}
      \centerAlignProof
      \quad
      \centerAlignProof
        \AxiomC{$\la{\n{repeat } S \n{ until } b}{s''}\rightarrow s'$}
        \UnaryInfC{$\la{\n{if}\ b\ \n{then skip else}\ (\n{repeat } S \n{ until } b)}{s''} \to s'$}[$\text{if}^{\text{ff}}_{\text{ns}}$]
      \DisplayProof
      \quad
      \centerAlignProof
\end{center}

Pero entonces, 
 \begin{center}
              \centerAlignProof
              \quad
              \centerAlignProof
                \AxiomC{$\la{S}{s} \to s''$}
                \AxiomC{$\la{\n{if}\ b\ \n{then skip else}\ (\n{repeat } S \n{ until } b)}{s''} \to s'$}
                \BinaryInfC{$\la{S; \n{if } b \n{ then skip else } (\n{repeat } S \n{ until } b)}{s} \to s'$}[$\text{comp}_{\text{ns}}$]
              \DisplayProof
        \end{center}
\\


\noindent\textit{Parte 2.} Supongamos que $\la{S;\n{ if } b \n{ then } \n{skip } \n{else } \n{repeat } S \n{ until } b}{s}\to s'$. La única posibilidad es haber aplicado la regla $[\text{comp}_{\text{ns}}]$

\begin{center}
    \centerAlignProof
    \quad
    \centerAlignProof
    \AxiomC{$\la{S}{s} \to s_0$}
    \AxiomC{$\la{\n{if}\ b\ \n{then skip else}\ (\n{repeat } S \n{ until } b)}{s_0} \to s'$}
    \BinaryInfC{$\la{S;\n{if } b \n{ then } \n{skip } \n{else } \n{repeat } S \n{ until } b}{s}\to s'$}
    \DisplayProof
\end{center}
para algún $s_0 \in \textbf{State}$. Para la transición $\la{\n{if}\ b\ \n{then skip else}\ (\n{repeat } S \n{ until } b)}{s_0} \to s'$ tenemos dos posibilidades
\\ \\
\noindent\textit{(a)} Si $\fc{B}{b}s_0 = \textbf{tt}$ entonces únicamente existe la posibilidad de que se haya derivado de $[\text{if}^\nn{tt}_\nn{ns}]$:
\begin{center}
    \centerAlignProof
    \quad
    \centerAlignProof
    \AxiomC{$\la{skip}{s_0} \to s' $}
    \UnaryInfC{$\la{\n{if}\ b\ \n{then skip else}\ (\n{repeat } S \n{ until } b)}{s_0} \to s'$}
    \DisplayProof
\end{center}
y la única forma de que sea cierto $\la{skip}{s_0} \to s'$ es que $s_0 = s'$. Como se verifica $\la{S}{s} \to s_0$ entonces se verifica $\la{S}{s} \to s'$ y se puede aplicar la regla $[\text{repeat}^\nn{tt}_\nn{ns}]$:
\begin{center}
    \centerAlignProof
    \quad
    \centerAlignProof
    \AxiomC{$\la{S}{s} \to s' $}
    \UnaryInfC{$\la{\n{repeat } S \n{ until } b}{s} \to s'$}
    \DisplayProof
\end{center}
obteniendo el resultado pues ya se sabe que $\la{S}{s} \to s_0$.
\\ \\
\noindent\textit{(b)}  Si $\fc{B}{b}s_0 = \textbf{ff}$ entonces solo cabe la posibilidad de que haya partido de $[\text{if}^\nn{ff}_\nn{ns}]$:

\begin{center}
    \centerAlignProof
    \quad
    \centerAlignProof
    \AxiomC{$\la{\n{repeat } S \n{ until } b}{s_0} \to s'$}
    \UnaryInfC{$\la{\n{if}\ b\ \n{then skip else}\ (\n{repeat } S \n{ until } b)}{s_0} \to s'$}
    \DisplayProof
\end{center}
teniendo así $\la{\n{repeat } S \n{ until } b}{s_0} \to s'$ y entonces se puede deducir
\begin{center}
    \centerAlignProof
    \quad
    \centerAlignProof
    \AxiomC{$\la{S}{s} \to s_0$}
    \AxiomC{$\la{\n{repeat } S \n{ until } b}{s_0} \to s'$}
    \BinaryInfC{$\la{\n{repeat } S \n{ until } b}{s} \to s'$}
    \DisplayProof
\end{center}
mediante $[\text{repeat}^\nn{ff}_\nn{ns}]$ pues $\fc{B}{b}s_0 = \textbf{ff}$. \\
\end{proof}


Para poder demostrar que una propiedad como la anterior se verifica en árboles sencillos y compuestos, emplearemos la demostración por \textit{inducción sobre reglas}, que se compone de dos pasos:
\begin{enumerate}
    \item Primero comprobamos que la propiedad se verifica para los axiomas del sistema.
    \item Para cada regla, suponiendo que las premisas verifican la propiedad , comprobamos que también se cumple para la conclusión (siempre y cuando se verifiquen las condiciones de la regla).
\end{enumerate}
\\

El siguiente resultado nos dice que, en general, hay \textit{una} manera de deducir una configuración mediante las reglas del sistema de transición $\nn{While}_\nn{ns}$:

\begin{theorem}\label{determinismo}
El sistema de transiciones $\nn{While}_{\nn{ns}}$ es determinista, es decir, para cada $S \in \mathbf{Stm}$, $s, s', s'' \in \mathbf{State}$,  
$$\la{S}{s}\rightarrow s' \text{ y } \la{S}{s}\rightarrow s'' \text{ implica que } s'= s''.$$
\end{theorem}
\begin{proof}
Para simplificar la demostración, vamos a definir una propiedad sintáctica de las reglas del sistema $\nn{While}_\nn{ns}$. Decimos que dos reglas son \textit{independientes entre sí} cuando no es posible obtener una mediante la aplicación de la otra. Notemos que este es el caso de nuestro sistema: las reglas $[\nn{while}_\nn{ns}^\nn{tt}]$ y $[\nn{while}_\nn{ns}^\nn{ff}]$ son independientes entre sí porque ambas tienen premisas distintas (suponemos que $\mathbf{tt}$ y $\mathbf{ff}$ son distintos). Entonces, como cada regla es independiente de la otra, deducimos que, en caso de que tengamos $\la{S}{s}\rightarrow s'$ y $\la{S}{s}\rightarrow s''$, necesariamente tendremos que haber aplicado la misma única regla posible en los dos casos para llegar a las respectivas configuraciones. Es fácil convencerse entonces de que, por inducción sobre las reglas, la propiedad deseada se cumple.
\end{proof}
\\


\begin{example} Podemos añadir una semántica $\n{forVar}\ x\ \n{do}\ S$ que ejecute la sentencia $S$ siempre que $x$ sea distinto de $0$ y lo incremente en $1$ en cada iteración. Veamos que sería semánticamente equivalente a $\n{while}\ \neg (x=0)\ \n{do}\ (S; x:=x+1)$.
\\ \\
Primero, definimos la semantica de $\n{forVar}\ x\ \n{do}\ S$:
        \begin{center}
              \centerAlignProof
              \quad
              \centerAlignProof
                \AxiomC{}
                \LeftLabel{$[\text{for}^0]$ }
                \RightLabel{si $\fc{A}{x}s = 0$}
                \UnaryInfC{$\la{\n{forVar}\ x\ \n{do}\ S}{s} \to s$}
              \DisplayProof
        \end{center}
        
        \begin{center}
              \centerAlignProof
              \quad
              \centerAlignProof
                \AxiomC{}
                \LeftLabel{$[\text{for}^{\ne 0}]$ }
                \RightLabel{si $\fc{A}{x}s \ne 0$}
                \AxiomC{ $\la{S; x := x+1}{s} \to s'$ }
                \AxiomC{$\la{\n{forVar}\ x\ \n{do}\ S}{s'} \to s_1$}
                \BinaryInfC{$\la{\n{forVar}\ x\ \n{do}\ S}{s} \to s_1$}
              \DisplayProof
        \end{center}

\noindent Veamos que $\la{\n{forVar}\ x\ \n{do}\ S}{s} \to s_1$ implica $\la{\n{while}\ \neg (x=0)\ \n{do}\ (S; x:=x+1)}{s}\to s_1 $.\\
Para empezar, sabemos que $\fc{A}{x}s = 0$ si y solo si $\fc{B}{\neg (x=0) }s = \mathbf{ff}$, dividimos la demostración en dos pasos:

\begin{enumerate}
    \item Si $x=0$ tenemos por $[\text{for}^0]$ que:
    \begin{center}
              \centerAlignProof
              \quad
              \centerAlignProof
                \AxiomC{$\la{\n{forVar}\ x\ \n{do}\ S}{s} \to s$}
              \DisplayProof
        \end{center}
        
    Como $\fc{B}{\neg (x=0) }s = \mathbf{ff}$ por la regla [$\text{while}^{\text{ff}}_{\text{ns}}$] sabemos que:

    \begin{center}
          \centerAlignProof
       
          \quad
          \centerAlignProof
            \AxiomC{$\la{\n{while}\ \neg (x=0)\ \n{do}\ (S; x:=x+1)}{s} \to s$}
          \DisplayProof
          \quad
          \centerAlignProof
    \end{center}    
    
    \item Si $ x\ne0$, entonces suponemos ciertas las siguientes premisas:
    \begin{enumerate}[a)]
        \item  \AxiomC{$\la{S; x := x+1}{s} \to s_2$} \DisplayProof
        \item   \AxiomC{$\la{\n{forVar}\ x\ \n{do}\ S}{s_2} \to s_1$} \DisplayProof
    \end{enumerate}
    
    
    pues la transición $\la{\n{forVar}\ x\ \n{do}\ S}{s} \to s'$ solo puede haber provenido de:
    
    \begin{center}
              \centerAlignProof
              \quad
              \centerAlignProof
                
                \AxiomC{ $\la{S; x := x+1}{s} \to s_2$ }
                \LeftLabel{$[\text{for}^{\ne 0}]$}
                \AxiomC{$\la{\n{forVar}\ x\ \n{do}\ S}{s_2} \to s'$}
                \BinaryInfC{$\la{\n{forVar}\ x\ \n{do}\ S}{s} \to s'$}
              \DisplayProof
        \end{center}
    Podemos aplicar la hipótesis de inducción sobre $\la{\n{forVar}\ x\ \n{do}\ S}{s_2} \to s'$ y por lo tanto tenemos que $\la{\n{forVar}\ x\ \n{do}\ S}{s_2} \to s'$ implica que $\la{\n{while}\ \neg (x=0)\ \n{do}\ (S; x:=x+1)}{s_2} \to s' $, luego podemos costruir el siguiente árbol de derivación:
    
    \begin{center}
              \centerAlignProof
              \quad
              \centerAlignProof
                
                \AxiomC{ $\la{S; x := x+1}{s} \to s_2$ }
                \LeftLabel{ [$\text{while}^{\text{tt}}_{\text{ns}}$]}
                \AxiomC{$\la{\n{while}\ \neg (x=0)\ \n{do}\ (S; x:=x+1)}{s_2} \to s'$}
                \BinaryInfC{$\la{\n{while}\ \neg (x=0)\ \n{do}\ (S; x:=x+1)}{s} \to s'$}
              \DisplayProof
        \end{center}
\end{enumerate}
Supongamos ahora que $\la{\n{while}\ \neg (x=0)\ \n{do}\ (S; x:=x+1)}{s}\to s'$. Entonces, distinguimos los siguientes casos:
\begin{enumerate}
    \item Si hemos aplicado [$\text{while}^{\text{ff}}_{\text{ns}}$], entonces 
    \begin{center}
      \centerAlignProof
       
      \quad
      \centerAlignProof
        \AxiomC{}
        \UnaryInfC{$\la{\n{while}\ \neg (x=0)\ \n{do}\ (S; x:=x+1)}{s} \to s'$}[$\text{while}^{\text{ff}}_{\text{ns}}$]
      \DisplayProof
      \quad
      \centerAlignProof
\end{center}
y además deducimos que $s=s'$ y que $x \neq 0$. Pero entonces tenemos que, directamente:
\begin{center}
              \centerAlignProof
              \quad
              \centerAlignProof
                \AxiomC{}
                \LeftLabel{$[\text{for}^0]$ }
                \RightLabel{}
                \UnaryInfC{$\la{\n{forVar}\ x\ \n{do}\ S}{s} \to s$}
              \DisplayProof
        \end{center}
es decir, obtenemos la implicación deseada.
    \item Si hemos aplicado [$\text{while}^{\text{tt}}_{\text{ns}}$], 
\begin{center}
      \centerAlignProof
        
      \quad
      \centerAlignProof
        \AxiomC{$\la{(S; x:=x+1)}{s} \to s'$}
        \AxiomC{$\la{\n{while}\  \neg (x=0)\ \n{do}\ (S; x:=x+1)}{s'} \to s''$}
        \BinaryInfC{$\la{\n{while}\ \neg (x=0)\ \n{do}\ (S; x:=x+1)}{s} \to s''$}[$\text{while}^{\text{tt}}_{\text{ns}}$]
      \DisplayProof
      \quad
      \centerAlignProof
\end{center}
y además deducimos que $x \neq 0$. Si aplicamos hipótesis de inducción sobre $\la{\n{while}\  \neg (x=0)\ \n{do}\ (S; x:=x+1)}{s'} \to s''$, obtenemos que $\la{\n{forVar}\ x\ \n{do}\ S}{s'} \to s''$. Pero entonces, juntando las premisas anteriores,  
  \begin{center}
              \centerAlignProof
              \quad
              \centerAlignProof
                \AxiomC{}
                \LeftLabel{$[\text{for}^{\ne 0}]$ }
                \RightLabel{}
                \AxiomC{ $\la{S; x := x+1}{s} \to s'$ }
                \AxiomC{$\la{\n{forVar}\ x\ \n{do}\ S}{s'} \to s''$}
                \BinaryInfC{$\la{\n{forVar}\ x\ \n{do}\ S}{s} \to s''$}
              \DisplayProof
        \end{center}
luego obtenemos el resultado.
\end{enumerate}
\end{example}
\\

\subsection{Expresiones}

Finalmente, podemos definir el valor semántico de cada $S \in \mathbf{Stm}$ mediante una aplicación
$\mc{S}_\nn{ns}: \mathbf{Stm} \rightarrow (\mathbf{State}\hookrightarrow\mathbf{State})$, donde
\begin{align*}
    \mc{S}_\nn{ns}[[S]]:  \mathbf{State} & \hookrightarrow  \mathbf{State} \\
                     s               & \mapsto          \begin{cases} s' \text{, si } \la{S}{s}\to s' \\ 
                        \nn{indefinido} \text{, en otro caso}
                        \end{cases}
\end{align*}
El determinismo de $\nn{While}_\nn{ns}$ implica que está bien definida. Además, es parcial porque, como vimos, la expresión $\n{while true do skip}$ siempre entra en bucle, es decir, $ \mc{S}_\nn{ns}[[\n{while true do skip}]]s = \mathrm{indefinido}$, para cada $s \in \mathbf{State}$.



\section{Semántica operacional estructural}

\subsection{Sistema de transiciones}

Ahora nos centramos en los pasos concretos de la ejecución de un programa. Para ello, definimos una relación de transición $\la{S}{s} \dto \gamma$ como:
\begin{itemize}
    \item Si $\gamma$ es de la forma $\la{S'}{s'}$, entonces la ejecución de $S$ desde $s$ no se completa y sigue en $\la{S'}{s'}$.
    \item Si $\gamma$ es de la forma $s'$, entonces la ejecución finaliza en el estado $s'$.
\end{itemize}
La nueva relación de transición queda determinada por el conjunto de reglas:

\begin{sist*}[$\nn{While}_\nn{sos}$]\mbox{}
\begin{itemize}
    \item[] $[\text{ass}_{\nn{sos}}]$
\begin{prooftree}
    \AxiomC{}
    \LeftLabel{}
    \UnaryInfC{ $\la{x:=a}{s} \dto s[x\mapsto \fc{A}{a}s]$}
\end{prooftree}
    \item[]$[\text{skip}_{\nn{sos}}]$
\begin{prooftree}
    \AxiomC{}
    \LeftLabel{}
    \UnaryInfC{$\la{\n{skip}}{s} \dto s$}
\end{prooftree}
    \item[]$[\text{comp}_{\nn{sos}}^1]$
\begin{prooftree}
    \AxiomC{$\la{S_1}{s} \dto \la{S_1'}{s'}$}
    \LeftLabel{}
    \UnaryInfC{ $\la{S_1; S_2}{s} \dto \la{S_1'; S_2}{s'}$}
\end{prooftree}
    \item[]$[\text{comp}_{\nn{sos}}^2]$
\begin{prooftree}
    \AxiomC{$\la{S_1}{s} \dto s'$}
    \LeftLabel{}
    \UnaryInfC{ $\la{S_1; S_2}{s} \dto \la{S_2}{s'}$}
\end{prooftree}
    \item[]$[\text{if}^{\nn{tt}}_{\nn{sos}}]$
\begin{prooftree}
    \AxiomC{}
    \LeftLabel{}
    \RightLabel{si $\fc{B}{b}s = \textbf{tt}$}
    \UnaryInfC{$\la{\n{if}\ b\ \n{then}\ S_1\ \n{else}\ S_2}{s} \dto \la{S_1}{s}$}
\end{prooftree}
    \item[]$[\text{if}_{\nn{sos}}^\nn{ff}]$
\begin{prooftree}
    \AxiomC{}
    \LeftLabel{}
    \RightLabel{si $\fc{B}{b}s = \textbf{ff}$}
    \UnaryInfC{$\la{\n{if}\ b\ \n{then}\ S_1\ \n{else}\ S_2; s}{s} \dto \la{S_2}{s}$}
\end{prooftree}

    \item[] $[\nn{while}_\nn{sos}]$
\begin{prooftree}
    \AxiomC{}
    \LeftLabel{}
    \RightLabel{}
    \UnaryInfC{$\la{\n{while }b\n{ do }S}{s}\dto \la{\n{if }b\n{ then }(S; \n{while }b\n{ do }S)\n{ else skip}}{s}$}
\end{prooftree}    
\end{itemize}
\end{sist*}
\\ \\

Notemos que podríamos haber incluido, por ejemplo, dos reglas para la semántica de $\n{while }b \n{ do }S$:
 
\begin{prooftree}
    \AxiomC{}
    \LeftLabel{$[\nn{while}_\nn{sos}^\nn{ff}]$}
    \RightLabel{ si $\fc{B}{s}= \mathbf{ff}$}
    \UnaryInfC{$\la{\n{while }b\n{ do }S}{s}\dto s$}
\end{prooftree}    
y
\begin{prooftree}
    \AxiomC{}
    \LeftLabel{$[\nn{while}_\nn{sos}^\nn{tt}]$}
    \RightLabel{ si $\fc{B}{s}= \mathbf{tt}$}
    \UnaryInfC{$\la{\n{while }b\n{ do }S}{s}\dto \la{S;\n{while }b\n{ do }S}{s}$}
\end{prooftree}    
\\

\begin{definition}
Se dirá que $\la{S}{s}$ está \textit{bloqueada} si no existe $\gamma$ tal que $\la{S}{s} \dto \gamma$. Una secuencia de derivación es finita cuando llega a un bloqueo o a un estado final:
\[
    \gamma_0 \dto \gamma_1 \dto ... \dto \gamma_k
\]
donde $\gamma_0 = \la{S}{s}$,  $\gamma_i \dto \gamma_{i+1}$ para $i\in\{0, ..., k-1\}$ y $\gamma_k$ es una configuración bloqueada.
\end{definition}

Normalmente escribiremos $\gamma_0 \dto^i \gamma$ si hay $i$ pasos en la ejecución de $\gamma_0$ a $\gamma$. Si hay finitos pasos, denotamos $\gamma_0 \dto^* \gamma$. $\gamma_0 \dto^i \gamma$ y $\gamma_0 \dto^* \gamma$ no tiene por qué ser secuencias de derivación, solo si $\gamma$ es configuración final o de bloqueo.

\begin{definition}
La ejecución $\la{S}{s}$ de la expresión $S$ en un estado $s$:
\begin{enumerate}
    \item \textit{Termina} si existe una única secuencia de derivación finita comenzando en $\la{S}{s}$.

    \item \textit{Termina con éxito} si $\la{S_1}{s} \dto ^* s'$ para algún estado $s'$.
    
    \item \textit{Cicla} si existe una secuencia de derivación infinita comenzando en $\la{S}{s}$.
\end{enumerate}
Nótese que estas definiciones son mutuamente excluyentes si y solo si las secuencias de derivacion son únicas. Por comodidad, las definimos de este modo porque, si extendemos el lenguaje, no nos tendremos que preocupar.
\end{definition}

\begin{example}
Supongamos que queremos extender $\nn{While}_\nn{sos}$ con la expresión $\n{repeat }S \n{ until }b$. Podemos añadir la regla:
\begin{prooftree}
        \AxiomC{}
        \LeftLabel{$[\nn{repeat}_\nn{sos}]$}
        \RightLabel{}
        \UnaryInfC{$\la{\n{repeat }S\n{ until }b}{s}\dto \la{S; \n{if }b\n{ then skip else }(\n{repeat }S\n{ until }b)}{s}$}
\end{prooftree}
La idea es que la expresión $\n{repeat }S\n{ until }b$ sea equivalente a $S;\n{ while }\neg b\n{ do } S$. Se definirá posteriormente el concepto de equivalencia semántica y se demostrará este resultado.
\end{example}

\subsection{Propiedades}

El método de demostración principal consiste en hacer \textit{inducción sobre la longitud de las secuencias de derivación} (finitas) que se estudian, es decir, si queremos demostrar una propiedad acerca de nuestro sistema de transiciones:
\begin{itemize}
    \item Demostramos que la propiedad se cumple para secuencias de derivación de longitud 0 (en ocasiones nos encontraremos que se cumple la propiedad de forma vacía).
    \item Demostramos que si la propiedad se cumple para secuencias de longitud (a lo sumo) $k$, entonces se cumple para secuencias de longitud $k+1$.
\end{itemize}
A modo de ejemplo de este método, veamos el siguiente resultado:

\begin{lema}\label{lemasos1}
Si $\la{S_1;S_2}{s}\dto^k s''$, entonces existen $s'\in \mathbf{State}$, $k_1, k_2 \in \N$ tales que $k = k_1 + k_2$ y $$\la{S_1}{s}\dto^{k_1}s' \quad \text{ y }\quad \la{S_2}{s'}\dto^{k_2}s''.$$
\end{lema}
\begin{proof}
Si $k=0$, entonces $\la{S_1;S_2}{s}\dto^0 s''$ implica (vacuamente) el resultado, porque $\la{S_1;S_2}{s}$ y $s''$ son distintos. Supongamos que el resultado se cumple para longitudes menores o iguales que $k$. Veamos que se sigue para $k+1$. Por tanto, tenemos la premisa $\la{S_1;S_2}{s}\dto^{k+1} s''$, es decir, que existe una configuración $\gamma$ tal que
$$\la{S_1;S_2}{s}\dto \gamma \dto^{k} s''$$
Por tanto, distinguimos dos casos según la regla que hemos aplicado a $\la{S_1;S_2}{s}$ para llegar a $\gamma$:
\begin{itemize}
    \item[(a)] Si hemos aplicado [$\nn{comp}^1_\nn{sos}$], tenemos que
\begin{prooftree}
    \AxiomC{$\la{S_1}{s} \dto \la{S_1'}{s'}$}
    \LeftLabel{$[\text{comp}_{\nn{sos}}^1]$}
    \UnaryInfC{ $\la{S_1; S_2}{s} \dto \la{S_1'; S_2}{s'}= \gamma$}
\end{prooftree}
luego $\la{S_1'; S_2}{s'} \dto^k s''$. Entonces, como esta derivación es de longitud $k$, podemos aplicar hipótesis de inducción, esto es, existen $s_0 \in \mathbf{State}$ y $k_1, k_2 \in \N$ con $k = k_1 + k_2$ y 
$$\la{S_1'}{s'}\dto^{k_1}s_0 \quad \text{ y }\quad \la{S_2}{s_0}\dto^{k_2}s''.$$
Ahora bien, como tenemos la premisa $\la{S_1}{s} \dto \la{S_1'}{s'}$ y $\la{S_1'}{s'}\dto^{k_1}s_0$, entonces tenemos que $\la{S_1}{s}\dto^{k_1 + 1}s_0$. Por otro lado, también tenemos $\la{S_2}{s_0}\dto^{k_2}s''$ y que $(k_1 + 1) + k_2 = (k_1 + k_2)+1 = k+1$. Es decir, hemos obtenido la conclusión deseada. Por tanto, hemos probado el resultado para este caso.

\item[(b)] Si hemos aplicado [$\nn{comp}^2_\nn{sos}$], tenemos que
\begin{prooftree}
    \AxiomC{$\la{S_1}{s} \dto s'$}
    \LeftLabel{[$\nn{comp}^2_\nn{sos}$]}
    \UnaryInfC{ $\la{S_1; S_2}{s} \dto \la{S_2}{s'}= \gamma$}
\end{prooftree}
Entonces deducimos que $\la{S_2}{s'} \dto^{k}s''$. Simplemente tomando $k_1 := 1$ y $k_2 := k$ vemos que $k_1+k_2 = k+1$ y que tenemos el resultado.
\end{itemize}
\end{proof}

\begin{example}
Por otro lado, $\la{S_1;S_2}{s}\dto^* \la{S_2}{s'}$ no implica necesariamente que $\la{S_1}{s}\dto^* s'$. Por ejemplo, podemos tomar $S_1 := \n{skip}$, $S_2 := \n{while }\neg(\n{x}=1)\n{ do } \n{x}:=\n{x}+1$ y $s\n{x} = 3$, $s'\n{x} = s[\n{x}\mapsto 2]$.
\end{example}


El siguiente lema viene a decir que la ejecución de una expresión es independiente de cualquier enunciado que se ejecute después:

\begin{lema}\label{lemasos2}
Si $\la{S_1}{s}\dto^k s'$, entonces $\la{S_1;S_2}{s}\dto^k \la{S_2}{s'}$.
\end{lema}
\begin{proof}
Por inducción sobre la longitud de las derivaciones. En caso de $k=0$, la premisa es falsa y el resultado se tiene directamente. Supongamos que se cumple el resultado para longitudes $\leq k$ y veámoslo para $k+1$. Nuestra suposición es que $\la{S_1}{s}\dto^{k+1} s'$. Entonces tenemos que hay cierta configuración $\gamma$ con 
$$\la{S_1}{s}\dto \gamma \dto^k s'$$
y además, notemos que $\gamma = \la{S}{s''}$ porque $k\leq 1$. Pero entonces, aplicando la hipótesis de inducción a $\la{S}{s''} \dto^k s'$, tenemos que $\la{S;S_2}{s''}\dto^k \la{S_2}{s'}$. 

Por otro lado, de $\la{S_1}{s}\dto \la{S}{s''}$ podemos deducir que:
\begin{prooftree}
    \AxiomC{$\la{S_1}{s} \dto \la{S}{s''}$}
    \LeftLabel{$[\text{comp}_{\nn{sos}}^1]$}
    \UnaryInfC{ $\la{S_1; S_2}{s} \dto \la{S; S_2}{s''}$}
\end{prooftree}
Es decir, sabemos que $\la{S_1; S_2}{s} \dto \la{S; S_2}{s''}$ y que $\la{S;S_2}{s''}\dto^k \la{S_2}{s'}$. Basta componer ambas derivaciones para ver que $\la{S_1; S_2}{s}\dto^{k+1} \la{S_2}{s'}$, como queríamos.
\end{proof}

\begin{theorem}
El sistema de transiciones $\nn{While}_\nn{sos}$ es determinista, es decir, para cualesquiera $S, s, \gamma, \gamma'$ tenemos que
$$\la{S}{s}\dto \gamma \text{ y } \la{S}{s}\dto \gamma' \text{ implica que } \gamma = \gamma'$$
\end{theorem}
\begin{proof}
Véase la demostración del Teorema \ref{determinismo}.
\end{proof}

\begin{definition}
Dos expresiones $S_1, S_2$ se dicen \textit{semánticamente equivalentes} si, para cada $s \in \mathbf{State}$, 
\begin{itemize}
    \item Si $\gamma$ es estado final o bloqueado, entonces $\la{S_1}{s}\dto^* \gamma$ si y solo si $\la{S_2}{s} \dto^*\gamma$. Nótese que las longitudes de las derivaciones no tienen por qué coincidir.
    \item La\footnote{La unicidad viene dada por el determinismo de $\nn{While}_\nn{sos}$.} secuencia de derivación empezando en $\la{S_1}{s}$ es infinita si y solo si lo es la que empieza en $\la{S_2}{s}$.
\end{itemize} 
\end{definition}