\cleardoublepage
\chapter{Semántica denotacional}


Hasta ahora, lo que nos ha interesado de los programas era su ejecución. En cambio, como ya dijimos en la introducción, lo que queremos estudiar ahora es el efecto de esta ejecución, es decir, la relación entre los estados iniciales y los finales asociados a ella.  Para ello, lo que haremos es definir una función semántica para cada categoría sintáctica, en el sentido de que cada construcción sintáctica será interpretada mediante un objeto matemático, el `efecto' de ejecutar tal construcción. 
\\

Este enfoque no es del todo desconocido para nosotros. Por ejemplo, las funciones semánticas $\mc{A}$ y $\mc{B}$ que ya hemos empleado son un ejemplo típico de definición denotacional: a cada expresión aritmética asociamos un objeto abstracto, más concretamente, una función de tipo $\mathbf{State}\rightarrow \mathbf{Z}$. Y lo mismo ocurre con las expresiones booleanas y las correspondientes funciones de $\mathbf{State}\rightarrow \mathbf{Bool}$. Recordemos que una característica importante de esta definiciones era la composicionalidad (véase la introducción). Por tanto, las funciones $\mc{S}_\nn{ns}$ y $\mc{S}_\nn{sos}$ no se corresponden con la idea de definición denotacional que hemos descrito.

\section{Sistema para While}

\subsection{Función semántica}

Las sentencias modifican el estado en el que se encuentran. Por tanto, en el enfoque denotacional, se define una aplicación que, dada una sentencia, devuelve una función (parcial) que transforma estados en estados:
\[
    \mc{S}_\nn{ds} : \mathbf{Stm} \to (\State \hookrightarrow \State)
\]
Notemos que $ \mc{S}_\nn{ds}$ es parcial precisamente por la sentencia $\n{while true do skip}$. Veamos, caso por caso, qué función es exactamente la que asignamos.
\\

Si reflexionamos en lo que implica la ejecución de $x:= a$, parecerá natural que le corresponda una aplicación que modifica, en cada estado, el valor que toma $x$. Más precisamente, una definición de este tipo sería:
\[
    \mc{S}_\nn{ds} [[x:=a]] : s \mapsto s[x\mapsto \fc{A}{a}s]
\]
es decir, dado un estado $s$, lo convertiremos a un estado en el cual la variable $x$ toma el valor $\fc{A}{a}s$. 
\\

En el caso de $\nskip$ queremos que no se ejecute ningún cambio en el estado. Lo reflejamos mediante la identidad $id : \State \to \State$, dada por $id(s) := s$\footnote{Se hace notar que podríamos dar definiciones de las aplicaciones recurriendo a imágenes de estados arbitrarios. En este caso no se ha utilizado la variable estado $s$, porque no la necesitamos para modificar el estado posterior (en el caso anterior necesitamos $s$ para saber el valor de la expresión aritmética $a$). Se podría haber definido, de forma equivalente, $\mc{S}_\nn{ds} [[\nskip]]s := s$, para todo $s \in \mathbf{State}$.}:
\[
    \mc{S}_\nn{ds} [[\nskip]] := id
\]

Para la composición de dos sentencias, $S_1; S_2$, simplemente queremos recibir el estado al que se llega tras ejecutar $S_1$ y después aplicar $S_2$. Esto lo podemos hacer mediante la composición:
\[
    \mc{S}_\nn{ds} [[S_1;S_2]] := \mc{S}_\nn{ds} [[S2]] \circ \mc{S}_\nn{ds} [[S_1]]
\]
Es muy importante tener en cuenta que $\mc{S}_\nn{ds} [[S_1]]$ se evalúa antes, pasando su resultado a $\mc{S}_\nn{ds} [[S_2]]$. 
\\

La idea para el condicional es la siguiente:
\[
    \mc{S}_\nn{ds} [[\nif b\nthen S_1\nelse S_2]]s := 
    \begin{cases}  
        \mc{S}_\nn{ds} [[S1]]s\text{, si } \fc{B}{b}s = \textbf{tt} \\
        \mc{S}_\nn{ds} [[S2]]s\text{, si } \fc{B}{b}s = \textbf{ff}
   \end{cases}
\]
donde sencillamente se ha utilizado el valor $\fc{B}{b}s$ para separar en dos casos y, según el resultado, aplicar una sentencia u otra. Pero, como dijimos antes, suele ser más cómodo emplear notación funcional. Podemos definir entonces una aplicación auxiliar $\n{cond} : (\State \to \mathbf{Bool}) \times (\State \hookrightarrow  \State) \times (\State \hookrightarrow  \State) \to (\State \hookrightarrow  \State)$, bajo la idea de que el primer parámetro será la evaluación de la expresión booleana (en función del estado) y las otras dos serán las evaluaciones de las sentencias $S_1$ y $S_2$\footnote{Hemos empleado el producto de tipos para mayor simplicidad. También podríamos haber escrito $\n{cond} : (\State \to \mathbf{Bool}) \to (\State \hookrightarrow  \State) \to (\State \hookrightarrow  \State) \to (\State \hookrightarrow  \State)$ y por tanto prescindir de paréntesis. Puede que, en un aspecto puramente formal, esta diferencia no sea relevante. En cambio, sí que es importante señalarla desde el punto de vista de los tipos de datos que emplea $\n{cond}$. También podríamos haber sustituido el tipo de funciones $\mathbf{State}\to \mathbf{Bool}$ por el tipo simple $\mathbf{Bool}$ pero, de nuevo, recordemos que es preferible trabajar con funciones.}. Para ello, según el valor que retorne el booleano, se devolverá el primer parámetro o el segundo, es decir:
\[
    \n{cond}(f_b, f_1, f_2) s := 
    \begin{cases}
        
        f_1s\text{, si } f_bs = \textbf{tt}  \\
        f_2 s\text{, si } f_bs = \textbf{ff} 
    \end{cases}
\]
Por tanto, la definición deseada es:
\[
    \mc{S}_\nn{ds} [[\nif b\nthen S_1\nelse S_2]] := \n{cond}(\fc{B}{b}, \mc{S}_\nn{ds} [[S_1]], \mc{S}_\nn{ds} [[S_2]])
\]
Esto es, si $b$ es cierto en el estado actual, se toma la primera sentencia y, en caso contrario, la segunda. 
\\

Hemos visto que ha sido posible definir las expresiones básicas mediante aplicaciones relativamente sencillas. No ocurrirá lo mismo con la sentencia $\nwhile b \ndo S$. Podríamos intentar usar lo anterior, junto con la equivaencia semántica con la sentencia $\n{if }b\n{ then }(S; \n{while }b\n{ do }S)\n{ else skip}$, y así obtendríamos:
$$\mc{S}_\nn{ds}[[\nwhile b \ndo S]] := \n{cond}(\fc{B}{b}, \mc{S}_\nn{ds}[[\n{while }b\n{ do }S]]\circ \mc{S}_\nn{ds}[[S]], id)$$
Pero, ¿acaso es esto una definición aceptable? Entre otras cosas, no es composicional, y por tanto no podemos aceptarla. La igualdad anterior sí que significa, por otro lado, algo, a saber: que $\mc{S}_\nn{ds}[[\nwhile b \ndo S]]$ es \textit{punto fijo} de la función $F$ dada por $F(g) := \n{cond}(\fc{B}{b}, g\circ \mc{S}_\nn{ds}[[S]], id)$. De hecho, $F$ sí que admite una definición composicional porque en lo anterior solo aparecen construcciones estructuralmente más sencillas que $\nwhile b \ndo S$. Por tanto, la siguiente definición es más satisfactoria:
$$\mc{S}_\nn{ds}[[\nwhile b \ndo S]] := \n{fix}(F)$$
donde $\n{fix}: ((\mathbf{State}\hookrightarrow \mathbf{State})\to (\mathbf{State}\hookrightarrow \mathbf{State}))\to (\mathbf{State}\hookrightarrow \mathbf{State})$ nos lleva una aplicación (de apliaciones) a su punto fijo. 

\begin{example}
Sea $\n{while } \neg(\n{x} = 0)\n{ do skip}$. El funcional asociado es, en este caso:
$$G(g)s := \begin{cases}
    gs \text{, si } s\n{x} \neq 0\\
    s \text{, en otro caso}
\end{cases}$$
¿Hay algún punto fijo para $G$? Probemos con 
$$g_1s := \begin{cases}
    \n{INDEFINIDO} \text{, si } s\n{x}\neq 0 \\
    s \text{, en otro caso}
\end{cases}$$
En efecto, 
$$G(g_1)s = \begin{cases}
    g_1s \text{, si } s\n{x} \neq 0\\
    s \text{, en otro caso}
\end{cases} = \begin{cases}
    \n{INDEFINIDO} \text{, si } s\n{x}\neq 0 \\
    s \text{, en otro caso}
\end{cases} = g_1s$$
Luego $g_1 = \n{fix}(G)$. Por otro lado, $g_2 \equiv \n{INDEFINIDO}$ no puede ser punto fijo de $G$ porque, si $s \in \mathbf{State}$ verifica $sx = 0$, entonces $G(g_2)s = s \neq \n{INDEFINIDO} = g_2s$.
\end{example}


Entonces, de momento, tenemos las siguientes reglas: 

\begin{sist*}[$\nn{While}_\nn{ds}$]\label{whileds}
\begin{eqnarray*}
    \mc{S}_\nn{ds} [[x:=a]]s &:=& s[x\mapsto \fc{A}{a}s] \\
    \mc{S}_\nn{ds} [[\nskip]] &:=& id \\
    \mc{S}_\nn{ds} [[S_1;S_2]] &:=& \mc{S}_\nn{ds} [[S2]] \circ \mc{S}_\nn{ds} [[S_1]] \\
    \mc{S}_\nn{ds} [[\nif b\nthen S_1\nelse S_2]]s &=&  \n{cond}(\fc{B}{b}, \mc{S}_\nn{ds} [[S_1]], \mc{S}_\nn{ds} [[S_2]])\\
    \mc{S}_\nn{ds} [[\nwhile b \ndo S]] &:=&  \n{fix}(F)\\
\end{eqnarray*}
donde $F(g) := \n{cond}(\fc{B}{b}, g\circ \mc{S}_\nn{ds}[[S]], id)$.
\end{sist*}

Notemos que podríamos haber intentado definir 
$$\mc{S}_{ds}[[\n{while } b \n{ do } S]]s := \mc{S}_{ds}^{\delta(b, S)s}s$$
con 
$$\delta(b, S)s := \begin{cases}
    0 \text{, si } \fc{B}{b}s = \mathbf{ff} \\
    1 + \delta(b, S)s' \text{, en otro caso}
\end{cases}$$
Sería una definición composicional pero, en cambio, la aplicación $\delta(b, S)$ no está bien definida como función recursiva, porque podría darse el caso de que no devolviera ningún valor bien definido.

\subsection{Requisitos de punto fijo}

Ahora bien, si examinamos la definición que hemos dado para $\mc{S}_\nn{ds} [[\nwhile b \ndo S]]$, veremos que volvemos a tener problemas. Esta vez el obstáculo se encuentra en que hemos supuesto que cada aplicación asociada a una sentencia de la forma $\nwhile b \ndo S$ tiene \textit{un} punto fijo. La realidad es bien distinta: puede haber varios puntos fijos o incluso ninguno, como ilustran los siguientes ejemplos.

\begin{example}
Cualquier elemento $f \in  \mathbf{State}\hookrightarrow \mathbf{State}$, tal que $fs =s$ si $sx = 0$, es punto fijo de la aplicación $G$ del anterior ejemplo.
\end{example}

\begin{example}
Sean $g_1, g_2 \in \mathbf{State}\hookrightarrow\mathbf{State}$. La aplicación 
$$H(g) := \begin{cases}
     g_1 \text{, si } g = g_2\\
     g_2 \text{, en otro caso}
\end{cases}$$
no admite ningún punto fijo si $g_1 \neq g_2$ porque, si $H(g) = g$, entonces, o bien $g \neq g_2$ y $H(g)= g_2$, o bien $g = g_2$ y $H(g)= g_2 \neq g_1=g$.
\end{example}

Por tanto, como no podemos admitir que $\n{fix}$ devuelva un conjunto de candidatos a puntos fijos, parece irremediable dar una serie de requerimientos para seleccionar \textit{el} que nos interesa. La tarea, entonces, es doble, porque debemos probar que al menos y a lo sumo uno de los posibles puntos fijos verifica tales condiciones.
¿Qué condiciones dar? No entraremos mucho en detalle aquí, pero conviene tener una idea general de por qué exigimos determinadas restricciones. Podemos comenzar estudiando las diferentes configuraciones que se obtienen al ejecutar $\nwhile b \ndo S$ desde un estado $s_0$. Sea $F$ la aplicación asociada. Tenemos los siguientes casos:
\begin{itemize}
    \item[(a)] La ejecución termina. Por ejemplo, con $\n{while } 0≤\n{x do x} := \n{x}−1$ desde cualquier estado en el que $\n{x}\geq 0$.
    \item[(b)] La ejecución entra en un bucle local, es decir, hay alguna subexpresión en $S$ que entra en bucle. Por ejemplo, en $\n{while }0≤\n{x do }(\n{if x}=0 \n{ then }(\n{while true do skip})\n{ else x}:= \n{x}−1)$ desde cualquier estado con $\n{x}\geq 0$.
    \item[(c)] La ejecución entra en un bucle global, es decir, se entra en bucle al ejecutar la expresión completa. Por ejemplo, con $\n{while } ¬(\n{x}=0)\n{ do skip}$ desde cualquier estado con $\n{x}\neq 0$.
\end{itemize}
Más concretamente, 
\begin{itemize}
    \item[(a)] Hay una secuencia de estados $s_1, \dots, s_n$ tales que $\fc{B}{b}$ toma el valor $\mathbf{ff}$ únicamente en $s_n$ y con $\mc{S}_\nn{ds}[[S]]s_i=s_{i+1}$ para $i <n$. Si $F(g) = g$, entonces
    $$gs_i = F(g)s_i = \n{cond}(\fc{B}{b}, g\circ \mc{S}_\nn{ds}[[S]], id)$$
    y entonces es claro que $gs_i = s_{i+1}$, si $i <n$, y $gs_i = s_i$ si $i = n$. Pero entonces $gs_0 = s_n$.
    \item[(b)] Hay una secuencia de estados $s_1, \dots, s_n$ tales que $\fc{B}{b}$ toma el valor $\mathbf{tt}$ para cada $i \leq n$ y tales que $\mc{S}_\nn{ds}[[S]]s_i = s_{i+1}$, si $i <n$, y $\mc{S}_\nn{ds}[[S]]s_i = \n{INDEFINIDO}$, si $i = n$. Por un razonamiento análogo al anterior, podemos determinar que todo $g = F(g)$ verifica que $gs_0 = \n{INDEFINIDO}$.
    \item[(c)] Existe una secuencia infinita de estados $s_1, s_2, \dots$ tales que $\fc{B}{b}s_i =\mathbf{tt}$ y $\mc{S}_\nn{ds}[[S]]s_i = s_{i+1}$, para cada $i=1, 2, \dots$. Entonces, es fácil ver que, si $F(g)=g$,
$$gs_{i} = gs_{i+1}, \text{ para todo } i \in \N$$
Pero entonces $gs_0 = gs_i$, para cada $i\in \N$. Por tanto, siguiendo este método no podemos determinar el valor de $gs_0$.
\end{itemize}

Precisamente, esta anomalía del caso (c) es lo que nos indica que los posibles puntos fijos de $F$ pueden diferir entre sí. Para mayor claridad, centrémonos en el siguiente ejemplo:

\begin{example}
Consideremos $\n{while } ¬(\n{x}=0)\n{ do skip}$, ejecutado desde un estado $s_0$ con $\n{x}\neq 0$. En este caso, 
$$F(g)s := \begin{cases}
    gs \text{, si } s\n{x} \neq 0\\
    s \text{, en otro caso}
\end{cases}$$
Pero ya vimos que cualquier $g \in \mathbf{State}\hookrightarrow\mathbf{State}$ con $gs = s$ si $s\n{x} = 0$ era punto fijo de $F$. Por otro lado, está claro que la intuición nos dice que sería deseable tener
$$\mc{S}_\nn{ds}[[\n{while } ¬(\n{x}=0)\n{ do skip}]]s_0 := \begin{cases}
    \n{INDEFINIDO} \text{, si } s_0\n{x} = 0 \\
    s_0 \text{, en otro caso}
\end{cases}$$
Pero entonces, si tomamos ahora
$$hs := \begin{cases}
    \n{INDEFINIDO} \text{, si } s\n{x} = 0 \\
    s \text{, en otro caso}
\end{cases}$$
es claro que $F(h) = h$ y, \textit{además}, que $hs = s'$ implica $h's = s'$, para cualquier otro punto fijo $h'$ de $F$, pero no al contrario. 
\end{example}
Este ejemplo muestra que, en resumen, el candidato a $\n{fix}(F)$ debe ser cierto $h \in \mathbf{State}\hookrightarrow\mathbf{State}$ tal que:
\begin{itemize}
    \item[(1)] $F(h)=h$.
    \item[(2)] Sean $s, s' \in \mathbf{State}$. Si $g \in \mathbf{State}\hookrightarrow\mathbf{State}$ verifica (1), entonces
    $$hs =s' \text{ implica que } gs=s'$$
\end{itemize}
Nótese que, si $hs = \n{INDEFINIDO}$ entonces no se verifica (2). 


\begin{example}[Ejercicio 5.2] El funcional F asociado con la sentencia
\[
    \nwhile \neg(x=0) \ndo x:= x-1
\]
es, por definición $F(g) = \n{cond}(\fc{B}{\neg(x=0)}, g\circ\mathcal{S}_\nn{ds}[[x:= x-1]], \n{id})$, que aplicado a un estado $s$ puede verse de la forma
\begin{eqnarray*}
    F\ g (s) &=& \left\{\begin{array}{ll}
          g\circ\mathcal{S}_\nn{ds}[[x:= x-1]], \n{id}) (s) & \fc{B}{\neg(x=0)}s = \textbf{tt} \\
          s &  c.c
    \end{array}\right. \\
    &=& \left\{\begin{array}{ll}
          g(s[x \mapsto (s\ x) - 1]) & s\ x\neq 0 \\
          s &  s\ x = 0
    \end{array}\right.
\end{eqnarray*}
Ahora vamos a ver varios ejemplos de función $g$ y comprobaremos si son puntos fijos por $F$:
\begin{enumerate}
    \item La aplicación
    \[
        g_1\ s := \n{INDEFINIDO},\ \ \forall s\in\State
    \]
    no es un punto fijo. Tomemos por ejemplo un estado $s\in\State$ tal que $s\ x = 1$, entonces
    \begin{eqnarray*}
        s' &:=& (F\ g_1)\  s \\
        &=& \left\{\begin{array}{ll}
        g_1\ s[x \mapsto 0] & x\neq 0 \\
          s &  c.c\end{array}\right. \\
        &=& g_1\ s[x \mapsto 0]
    \end{eqnarray*}
    luego $s'\ x = \n{INDEFINIDO} \neq 1 = s\ x$, por lo que $g$ no es un punto fijo.
    \item La aplicación
    \[
         g_2\ s = \left\{\begin{array}{ll}
          s[x\mapsto 0] & s\ x \geq 0 \\
          \n{INDEFINIDO} &  s\ x < 0
    \end{array}\right.
    \]
    sí es un punto fijo. Sea $s\in\State$, supongamos $s\ x > 0$:
    \begin{eqnarray*}
        s' &:=& (F\ g_2)\  s \\
        &=& \left\{\begin{array}{ll}
        g_2\ s[x \mapsto s\ x - 1] & s\ x\neq 0 \\
          s &  s\ x=0\end{array}\right. \\
        &=& g_2\ s[x \mapsto s\ x - 1] \\
        &=& s[[x \mapsto s\ x - 1]][x \mapsto 0] \\
        &=& s[x \mapsto 0] = g_2\ s
    \end{eqnarray*}
    Para el caso $s\ x = 0$ sucede que
    \[
        (F\ g_2)\  s = s = s[x\mapsto 0] = g_2\ s
    \]
    Y finalmente si $x<0$, informalmente el bucle sería infinito:
    \[
        (F\ g_2)\  s = \n{INDEFINIDO} = g_2\ s
    \]
    Por lo que se deduce que $F\ g_2 = g_2$, luego es un punto fijo.
    \item Consideremos la aplicación
     \[
         g_3\ s = \left\{\begin{array}{ll}
          s[x\mapsto 0] & s\ x \geq 0 \\
          s &  s\ x < 0
    \end{array}\right.
    \]
    Tomemos $s\ x = -1$ entonces
    \begin{eqnarray*}
        (F\ g_3)\  s  &=&  g_3\ s[x \mapsto -2] \\
        &=& g_3\ s[x \mapsto -2] \neq s = g_3\ s
    \end{eqnarray*}
    Por lo que $F\ g_3 \neq g_3$ y entonces $g_3$ no es punto fijo.
    \item Definimos ahora $g_4\ s = s[x\mapsto 0]$ para todo $s\in\State$. Esta función es punto fijo:
    \begin{eqnarray*}
        (F\ g_4)\  s  &=& \left\{\begin{array}{ll}
        g_4\ s[x \mapsto s\ x -1] & s\ x\neq 0 \\
          s &  s\ x=0\end{array}\right. \\
        &=& \left\{\begin{array}{ll}
        s[x \mapsto 0] & x\neq 0 \\
        s &  s\ x = 0 \end{array}\right. \\
        &=& s[x \mapsto 0] = g_4\ s
    \end{eqnarray*}
    \item La aplicación identidad $g_5\ s = s$ no es un punto fijo. Sea $s\in\State$ tal que $s\ x = 1$ entonces
    \begin{eqnarray*}
        (F\ g_5)\ s  &=& g_5\ s[x\mapsto 0] \neq s = g_5\ s
    \end{eqnarray*}
    de lo que se deduce que $F\ g_5 \neq g_5$.
\end{enumerate}
\end{example}

\begin{example}[Ejercicio 5.3] Consideramos ahora la sentencia
\[
    \nwhile \neg(x=1)\ndo (y:=y*x; x:= x-1)
\]
Tiene por funcional $F$:
\begin{eqnarray*}
    (F\ g) s &=& \left\{\begin{array}{ll}
          g\circ\mathcal{S}_\nn{ds}[[y:=y*x; x:= x-1]], \n{id}) (s) & \fc{B}{\neg(x=1)}s = \textbf{tt} \\
          s &  c.c
    \end{array}\right. \\
    &=& \left\{\begin{array}{ll}
          g\ s[y\mapsto (s\ y)*(s\ x)][x\mapsto (s\ x)-1]& s\ x\neq 1 \\
          s &  s\ x = 1
    \end{array}\right.
\end{eqnarray*}
Este bucle hace un cálculo de $y\cdot x!$, por lo que es previsible que el punto fijo represente este hecho. \\ \\
Un ejemplo de punto fijo es la aplicación
\[
    f_1\ s = \left\{\begin{array}{ll}
    s[y\mapsto (s\ y)*(s\ x)!][x\mapsto 1] & si\ s\ x\geq 1 \\
    \n{INDEFINIDO} & \text{caso contrario}
    \end{array}\right.
\]
pues
\begin{eqnarray*}
    (F\ f_1)\ s &=& \left\{\begin{array}{ll}
          f_1\ s[y\mapsto (s\ y)*(s\ x)][x\mapsto (s\ x)-1]& s\ x\neq 1 \\
          s &  s\ x = 1
    \end{array}\right. \\
    &=& \left\{\begin{array}{ll}
          f_1\ s'[y\mapsto (s'\ y)*(s'\ x)][x\mapsto 1] & s\ x\neq 1 \land s'\geq 1 \\
          \n{INDEFINIDO} & s\ x\neq 1 \land s'< 1 \\
          s &  s\ x = 1
    \end{array}\right. \\
    &=& \left\{\begin{array}{ll}
          f_1\ s[y\mapsto (s\ y)*(s\ x)!][x\mapsto 1] & s\ x \geq 2 \\
          \n{INDEFINIDO} & s\ x < 1 \\
          s &  s\ x = 1
    \end{array}\right.\\ &=& f_1\ s
\end{eqnarray*}
donde $s' := s[y\mapsto (s\ y)*(s\ x)][x\mapsto (s\ x)-1]$-
También es un punto fijo
\[
    f_2\ s = s[y\mapsto (s\ y)*(s\ x)!][x\mapsto 1]
\]
pues es igual a $f_1$ salvo en los puntos en los que la primera función está indefinida.
\end{example}

\section{Conjuntos parcialmente ordenados}

Antes de formalizar todas las ideas anteriores, conviene repasar algunos resultados básicos sobre conjuntos parcialmente ordenados. Posteriormente, haremos referencia a éstos, aplicados a un caso especial que describiremos más adelante.

\begin{definition}
Un par $(D,  \sqsubseteq)$ formado por un conjunto $D$ y una relación $\sqsubseteq \ \subseteq D^2$ se dice \textit{conjunto parcialmente ordenado} si $\sqsubseteq$ es reflexiva, antisimétrica y transitiva. 
\end{definition}

Recordemos también que un elemento $d \in D$ se dice $\sqsubseteq$-\textit{mínimo} si, para cada $d' \in D$, $d \sqsubseteq d'$.

\begin{lema}
Si un conjunto parcialmente ordenado $(D, \sqsubseteq)$ tiene un elemento mínimo, entonces es único. 
\end{lema}
\begin{proof}
En otro caso, si hubiera dos mínimos, bastaría aplicar la definición de elemento mínimo y la antisimetría del orden parcial para comprobar que son iguales.
\end{proof}

Por tanto, si existe, denotaremos a tal elemento mínimo como $\bot$.

\begin{definition} 
Dados $(D, \sqsubseteq)$ parcialmente ordenado y $Y\subset D$, se dice que $d\in D$ es una \textit{cota superior} de $Y$ si, para cada $d' \in Y$, $d' \sqsubseteq d$.
\end{definition}

Llamaremos \textit{supremo} de $Y \subseteq D$ a la menor cota superior de $Y$ (respecto de $\sqsubseteq$).

\begin{lema}
Si $Y \subseteq D$ tiene un supremo respecto de un orden parcial, entonces es único.
\end{lema}
\begin{proof}
Basta repetir la demostración del lema anterior, esta vez para cotas superiores.
\end{proof}

Si existe tal supremo en $Y$, lo denotamos por $\bigsqcup Y$. Pasemos ahora a un concepto que será relevante más adelante. Recordemos que un conjunto $A$ se dice \textit{totalmente ordenado} por una relación de orden $<$ si, dados arbitrarios $x, y \in A$, $x < y$ o $y < x$.

\begin{definition}
Un subconjunto $C$ de un conjunto parcialmente ordenado $(D, \sqsubseteq)$ se llama \textit{cadena} si es totalmente ordenado.
\end{definition}

\begin{definition}
Un conjunto parcialmente ordenado $(D, \sqsubseteq)$ se llama \textit{completo} si, dada una cadena cualquiera $C$, existe $\bigsqcup C$. Si lo mismo ocurre para todos los subconjuntos de $D$, lo denominamos \textit{retículo completo}.
\end{definition}

\begin{prop}
Sea $(D, \sqsubseteq)$ es un conjunto parcialmente ordenado y completo. Entonces tiene un elemento mínimo $\bot := \bigsqcup \emptyset$.
\end{prop}
\begin{proof}
Claramente, $\emptyset$ es cadena (verifica la afirmación de forma vacía) y, como $D$ es completo por hipótesis, existe $\bigsqcup \emptyset$. Ahora bien, dado $d \in D$, por la definición de $\bigsqcup \emptyset$ es directo que se verifica $\bigsqcup\emptyset \sqsubseteq d$, luego obtenemos el resultado.
\end{proof}

\begin{definition}
Sean $(D, \leq)$ y $(E, \preccurlyeq)$ conjuntos ordenados. Una aplicación $f: D \to E$ se dice \textit{monótona} si $d \leq d'$ implica que $f(d) \preccurlyeq f(d')$, para cualesquiera $d, d' \in D$. 
\end{definition}

Es directo comprobar que la composición de aplicaciones monótonas es monótona.

\begin{lema}
Sean $(D, \sqsubseteq), (E, \preccurlyeq)$ conjuntos parcialmente ordenados completos y $f: D \to E$ monótona. Entonces, si $C \subseteq D$ es cadena, $f(C) \subseteq E$ también lo es. Además\footnote{Nótese que, en la expresión que aparece en el teorema, nos referimos, primero a un $\preccurlyeq$-supremo, y después a un $\sqsubseteq$-supremo. Confiamos en el lector para que esté atento al uso en cada caso.},
$$\bigsqcup f(C) \preccurlyeq f\left(\bigsqcup C\right).$$
\end{lema}
\begin{proof}
Si $C = \emptyset$, entonces $f(\emptyset)= \emptyset$ y, como $\bot_E\preccurlyeq f(\bot_D)$, tenemos el resultado. Por tanto, supongamos que $C \neq \emptyset$. Sean $e_1, e_2 \in f(C)$. Entonces existen $d_1, d_2 \in C$ con $f(d_1)=e_1$ y $f(d_2)=e_2$. Por ser $C$ cadena, $d_1 \sqsubseteq d_2$ o $d_2 \sqsubseteq d_1$ y, por monotonía de $f$, $e_1 \preccurlyeq e_2$ o $e_2 \preccurlyeq e_1$, luego $f(C)$ es efectivamente cadena.
\\

Para lo segundo, sea $d \in C$. Entonces, por definición, $d \sqsubseteq \bigsqcup C$ y, por monotonía, $f(d) \preccurlyeq f(\bigsqcup C)$. Es decir, $f(\bigsqcup C)$ es cota superior de $f(C)$. Pero entonces, por definición, $\bigsqcup f(C) \preccurlyeq f(\bigsqcup C)$.
\end{proof}

Aunque, en general, no es cierto que las aplicaciones monótonas preserven supremos, nos centraremos en ellas a continuación:
\begin{definition}
Sean $(D, \sqsubseteq), (E, \preccurlyeq)$ conjuntos parcialmente ordenados completos y $f: D \to E$ monótona. Decimos que $f$ es \textit{continua} si $\bigsqcup f(C) = f(\bigsqcup C)$ para cada cadena $C \neq \emptyset$. Si, además, $f(\bot_D) = \bot_E$, decimos que $f$ es \textit{estricta}.
\end{definition}

Es fácil comprobar que, si $f: D \to E$ es continua, entonces es monótona. También es fácil ver que composición de funciones continuas es continua, y que lo mismo ocurre para las funciones estrictas. 
\\

Llegamos de este modo al concepto que ha motivado toda la sección:

\begin{theorem}\label{fixth}
Sea $(D, \sqsubseteq)$ conjunto parcialmente ordenado completo. Sea $f: D \to D$ continua. Entonces,
$$\text{\n{fix}}(f) := \bigsqcup\{f^m(\bot) \, | \, m \in \N\}$$
define un elemento de $D$ y es precisamente el menor punto fijo de $f$\footnote{Aquí empleamos la notación $f^0 := id$, $f^{n+1} := f^n\circ f$.}.
\end{theorem}
\begin{proof}
Veamos que $\n{fix}(f)$ está bien definido. Primero, $id(\bot) = \bot$ y, claramente, $\bot \sqsubseteq d$ para cada $d \in D$. Supongamos que $f^n(\bot) \sqsubseteq f^n(d)$ para cada $d \in D$ y cierto $n > 0$. Entonces, por monotonía, $f^{n+1}(\bot) = f(f^n{\bot}) \sqsubseteq f(f^n(d)) = f^{n+1}(d)$. Entonces, es fácil comprobar que $f^n(\bot) \sqsubseteq f^{m}(\bot)$ si $n \leq m$. Pero entonces, $C:= \{f^n(\bot) \, | \, n \in \N\}$ es cadena no vacía en $D$ y, por completitud, existe $\n{fix}(f)$.
\\

Veamos que $f(\n{fix}(f)) = \n{fix}(f)$:
$$f(\n{fix}(f)) = f\left(\bigsqcup\{f^n(\bot) \, | \, n \geq 0\}\right) = \bigsqcup\{f^{n+1}(\bot) \, | \, n \geq 0\} = \bigsqcup\{f^{n}(\bot) \, | \, n \geq 1\}$$ 
porque $f$ es continua. Ahora, usando que $\bigsqcup (C \cup \{\bot\}) = \bigsqcup C$, para cada cadena $C$, y que $\bot = f^0(\bot)$,
$$\bigsqcup\{f^{n}(\bot) \, | \, n \geq 1\} = \bigsqcup(\{f^{n}(\bot) \, | \, n \geq 1\}\cup \{\bot\}) = \bigsqcup\{f^{n}(\bot) \, | \, n \geq 0\} = \n{fix}(f).$$
Finalmente, veamos que es el menor punto fijo. Sea $d$ otro punto fijo de $f$. Como $\bot \sqsubseteq d$, por monotonía se tiene que $f^n(\bot) \sqsubseteq f^n(d)$, para cada $n \geq 0$. Como $d$ es punto fijo, $f^n(\bot) \sqsubseteq d$, para cada $n \geq 0$, es decir, $d$ es cota superior de la cadena $\{f^n(d) \, | \, n \geq 0\}$. Pero, por definición, $\n{fix}(f) \sqsubseteq d$.
\end{proof}

\begin{prop}
Sea $f: D \to D$ continua con $(D, \sqsubseteq)$ parcialmente ordenado y completo. Sea $d \in D$ tal que $f(d)\sqsubseteq d$. Entonces, $\n{fix}(f) \sqsubseteq d$.
\end{prop}
\begin{proof}
Para empezar, por monotonía, deducimos que $f^n(d)\sqsubseteq \dots \sqsubseteq f(d) \sqsubseteq d$ y que $f^{n}(\bot) \sqsubseteq f^n(d)$, para cada $n \in N$. Pero, entonces, 
$$\n{fix}(f) := \bigsqcup\{f^n(\bot) \, | \, n \geq 0\} \sqsubseteq \bigsqcup\{f^n(d) \, | \, n \geq 0\} \sqsubseteq d.$$
\end{proof}


\section{Estudio del punto fijo}


\subsection{Descripción}

Regresemos entonces a nuestro problema original. Para empezar, vamos a definir un orden parcial en $\mathbf{State}\hookrightarrow \mathbf{State}$, recordando los requisitos de punto fijo que ya expusimos anteriormente:
\begin{definition}
Dadas $g_1, g_2 \in \mathbf{State}\hookrightarrow \mathbf{State}$, decimos que $g_1$ \textit{está menos definida que} $g_2$ si, para arbitrarios $s, s' \in \mathbf{State}$, $g_1 s = s'$ implica que $g_2 s = s'$. Simbolizaremos esta relación como $\sqsubseteq$. 
\end{definition}
Evidentemente, la anterior definición se puede reformular mediante pares, de modo que dice que $\nn{G}(g_1)\subseteq G(g_2)$, donde $G(f)$ denota el \textit{grafo} de $f$, es decir, el conjunto de los pares de los que se compone $f$.

\begin{lema}
$(\mathbf{State}\hookrightarrow \mathbf{State}, \sqsubseteq)$ es conjunto parcialmente ordenado con elemento mínimo dado por $\bot \equiv \n{INDEFINIDO}$.
\end{lema}
\begin{proof}
Las propiedades reflexiva y transitiva son directas. Veamos la antisimétrica. Sean $g_1 \sqsubseteq g_2 \sqsubseteq g_1$. Si $g_1s = s'$, entonces evidentemente se sigue que $g_2s = s'$. Si $g_1s = \n{INDEFINIDO}$, entonces $g_2s = \n{INDEFINIDO}$ porque, en otro caso, digamos que $g_2s = s'$, tendríamos que $g_1s=s'$, lo que es imposible.

Veamos lo segundo. Evidentemente, $\bot \in \mathbf{State}\hookrightarrow \mathbf{State}$. Además, $\bot s = s'$ implica de forma vacía que $gs = s'$, para cada $g \in \mathbf{State}\hookrightarrow \mathbf{State}$.
\end{proof}

\begin{example}
Sean $g_1, g_2, g_3, g_4 \in \mathbf{State}\hookrightarrow \mathbf{State}$:
$$g_1 := id$$
$$g_2 s := \begin{cases}
    s \text{, si } sx \geq 0 \\
    \n{INDEFINIDO} \text{, en otro caso}
\end{cases}$$
$$g_3 s := \begin{cases}
    s \text{, si } sx = 0 \\
    \n{INDEFINIDO} \text{, en otro caso}
\end{cases}$$
$$g_4 s := \begin{cases}
    s \text{, si } sx \leq 0 \\
    \n{INDEFINIDO} \text{, en otro caso}
\end{cases}$$
Entonces es claro que tenemos el siguiente diagrama de Hasse: 
$$
\begin{tikzcd}
&g_1& \\
&& \\
g_2\arrow[uur]{} && g_4\arrow[uul]{} \\
&& \\
&g_3\arrow[uul]{} \arrow[uur]{}&
\end{tikzcd}
$$
Donde cada arista indica que se da la relación de orden entre los nodos (en el sentido especificado). No aparecen las aristas obtenidas mediante transitividad (dicho de otro modo, la transitividad viene dada por llegar de un nodo a otro mediante un camino válido).
\end{example}
Entonces, las propiedades que debía cumplir un punto fijo para un funcional $F$ quedan como: 
\begin{itemize}
    \item[(a)] $F(\n{fix}(F)) =  \n{fix}(F)$.
    \item[(b)] Si $g$ es punto fijo de $F$, $\n{fix}(F) \sqsubseteq g$.
\end{itemize}
Además, es claro que, si $F$ tiene al menos un $\sqsubseteq$-menor punto fijo, entonces es único, por la antisimetría del orden.
\\

El siguiente ejemplo muestra cómo podemos hablar de cadenas en $\mathbf{State}\hookrightarrow \mathbf{State}$:
\begin{example}
Consideremos la sucesión $(g_n)\subseteq \mathbf{State}\hookrightarrow \mathbf{State}$ dada por
$$g_n\ s := \begin{cases}
    \n{INDEFINIDO} \text{, si } s\ x > n \\
    s[\n{x} \mapsto -1] \text{, si } 0 \leq s\ x < n\\
    s \text{, si } s\ x < 0
\end{cases}$$
Notemos que $g_n \sqsubseteq g_m$ si $n \leq m$ porque $g_n$ está indefinida para más casos que $g_m$. Entonces, $C: \{g_n \, | \, n \in \N\}$ es cadena. $C$ está acotada superiormente por
$$g\ s := \begin{cases}
    s[\n{x} \mapsto -1] \text{, si } 0 \leq s\ x\\
    s \text{, si } s\ x < 0
\end{cases}$$
y, de hecho, $g$ es supremo de $C$.
\end{example}

Tenemos el siguiente resultado:

\begin{lema}
$(\mathbf{State}\hookrightarrow \mathbf{State}, \sqsubseteq)$ es conjunto parcialmente ordenado completo. Si $C$ es una cadena en $\mathbf{State}\hookrightarrow \mathbf{State}$, entonces\footnote{Nótese que esto quiere decir que $(\bigsqcup C)s = s'$ si y solo si $gs = s'$, para cierta $g \in C$.}
$$G\left(\bigsqcup C\right) = \bigcup\{G(g) \, | \, g \in C\}.$$
\end{lema}
\begin{proof}
Veamos que $\bigcup\{G(g) \, | \, g \in C\}$ es grafo de una función parcial en $\mathbf{State}\hookrightarrow \mathbf{State}$. Sean $(s, s'), (s, s'')$ elementos de este conjunto. Entonces existen $g, h \in C$ tales que $gs = s'$ y $hs = s''$. Como $C$ es cadena, $h$ y $g$ son comparables, luego obtenemos $s' = gs = hs = s''$, como queríamos. 
\\

Sea entonces $g_0$ tal función parcial con $G(g_0) = \bigcup\{G(g) \, | \, g \in C\}$. Veamos que $g_0$ es cota superior de $C$: como es obvio que $G(g) \subseteq G(g_0)$ para cada $g \in C$, tenemos que $g \sqsubseteq g_0$.
\\

Finalmente, veamos que $g_0$ es el supremo de $C$. En efecto, si $g_1$ es otra cota superior de $C$, tendremos que $G(g) \subseteq G(g_1)$, para cada $g \in C$. Tomando la unión en cada lado, tenemos que 
$$G(g_0) = \bigcup\{G(g) \, | \, g \in C\} \subseteq G(g_1)$$
es decir, $g_0 \sqsubseteq g_1$, como queríamos.
\end{proof}

Con el siguiente ejemplo vemos qué aspecto tiene una aplicación continua en el caso especial que estudiamos:
\begin{example}
Recordemos el siguiente funcional asociado a $\n{while} \neg(\n{x}=0)\n{do skip}$:
$$F(g)s := \begin{cases}
    gs \text{, si } s\n{x} \neq 0\\
    s \text{, en otro caso}
\end{cases}$$
Veamos que es continuo. Tenemos que ver que $F$ es monótona y que $F(\bigsqcup C) = \bigsqcup F(C)$ para una cadena arbitraria $C\neq \emptyset$. Sean $g \sqsubseteq h$ cualesquiera. Entonces, basta ver la definición para notar que la relación de $F(g)$ y $F(h)$ depende únicamente de la que ya había entre $g$ y $h$, porque, si $F(g)s = s'$, entonces tenemos que $F(g)s$ puede ser $gs = s' = hs$ o bien puede ser $s$, es decir, $F(g)\sqsubseteq F(h)$. 
\\

Por otro lado, sea $C \neq \emptyset$ cadena y sea $\bigsqcup C$. Consideremos $F(\bigsqcup C)$. Sean $a$
\end{example}

\subsection{Existencia}

El Teorema \ref{fixth} aplicado al orden $\sqsubseteq$ nos dice que, bajo determinadas condiciones, $\n{fix}(\cdot)$ permite definir una función. En esta sección queremos estudiar estas condiciones. Para empezar, recordemos que definíamos 
$$\mc{S}_\nn{ds} [[\nwhile b \ndo S]] :=  \n{fix}(F),$$
siendo $F(g) := \n{cond}(\fc{B}{b}, g\circ \mc{S}_\nn{ds}[[S]], id)$. Por tanto, debemos verificar que $F$ verifica las condiciones de las que hablamos. El siguiente Lema nos da un resultado en esta dirección:

\begin{lema}
Sea $p \in \mathbf{State}\to\mathbf{Bool}$. La aplicación $\Phi(g, h) := \n{cond}(p, g, h)$ es continua en las dos variables $g, h$, es decir, tanto
$$F(g) := \n{cond}(p, g, g_0) \quad \text{como} \quad H(g) := \n{cond}(p, g_0, g)$$
son continuas, siendo $g_0 \in \mathbf{State}\hookrightarrow\mathbf{State}$.
\end{lema}
\begin{proof}
Vamos a demostrar la continuidad de $F$, el otro caso es análogo. Primero veamos la monotonía de $F$. Sean $g_1 \sqsubseteq g_2$. Supongamos que $F(g_1)s = s'$. Si $ps = \mathbf{tt}$, $F(g_1)s = g_1s = s'$ implica $s' = g_2s = F(g_2)s$. Si $ps = \mathbf{ff}$, $F(g_1)s = g_0s = F(g_2)s$ y el resultado es trivial.
\\

Veamos ahora la continuidad. Basta ver que, si $C \subseteq \mathbf{State}\hookrightarrow\mathbf{State}$ es una cadena arbitraria no vacía, $F(\bigsqcup C) \sqsubseteq \bigsqcup F(C)$ (la otra dirección viene dada, en general, por monotonía). Por lo que ya vimos antes, podemos ver que $G(F(\bigsqcup C)) \subseteq \bigcup \{G(F(g)) \, | \, g \in C\}$ para tener el resultado. Sea $(s, s')\in G(F(\bigsqcup C))$. Si $ps = \mathbf{tt}$, $F(\bigsqcup C)s = g_0s= s'$. Pero entonces, para cada $g \in C$, $F(g)s = g_0s = s'$. Si $ps = \mathbf{tt}$, $F(\bigsqcup C)s = (\bigsqcup C)s = s'$, es decir, $(s, s')\in G(\bigsqcup C) = \bigcup \{G(g) \, | \, g \in C\}$, luego existe cierta $h \in C$ con $hs = s'$, es decir, $F(h)s = s'$, lo que nos da el resultado.
\end{proof}

\begin{lema}
La aplicación $\Psi(g, h) := g \circ h$ es continua en las dos variables, es decir, tanto
$$F(g) := g \circ g_0\quad \text{como}\quad H(g) := g_0 \circ g$$
son continuas, siendo $g_0 \in \mathbf{State}\hookrightarrow\mathbf{State}$.
\end{lema}
\begin{proof}
Veamos el caso $F$. $F$ es monótona: $g_1 \sqsubseteq g_2$ implica $G(g_1)\subseteq G(g_2)$, luego
$$G(g_0)\circ G(g_1) \subseteq G(g_0)\circ G(g_2)$$
que prueba que $F(g):=g_0\circ g_1\sqsubseteq g_0\circ g_2 =: F(g_2)$.
\\
$F$ es continua: sea $C$ cadena no vacía cualquiera. Entonces, 
$$G\left(F\left(\bigsqcup C\right)\right) = G\left(\bigsqcup C \circ g_0\right) = G(g_0)\circ G\left(\bigsqcup C\right)$$
donde hemos empleado $\circ$ en el segundo miembro como la composición de relaciones\footnote{Sean $R \subseteq A \times B, S \subseteq B \times C$. La \textit{composición} de $R$ y $S$ se define como
$$R \circ S := \{(x, z) \in A \times C \, | \, \exists y \in B.(xRy \land ySz)\}$$
Entonces, notemos que el orden de composición difiere del que tenemos para las funciones, es decir, $$G(f \circ g) = G(g) \circ G(f).$$}.
Ahora bien, lo anterior es igual a
$$G(g_0)\circ \bigcup \{G(g) \, | \, g \in C\} = \bigcup \{G(g_0)\circ G(g) \, | \, g \in C\} = G\left(\bigsqcup F(C)\right).$$
\end{proof}


\begin{theorem}
El sistema de semántica denotacional para $\n{While}$ define una función total $\mc{S}_\nn{ds}:\mathbf{Stm}\to (\mathbf{State}\hookrightarrow\mathbf{State})$.
\end{theorem}
\begin{proof}
Como tenemos definiciones composicionales, la demostración es por inducción estructural sobre la metavariable $S \in \mathbf{Stm}$. Los casos base son:
\begin{itemize}
    \item[(i)] Si $S$ es de la forma $x := a$, entonces basta comprobar que la aplicación $s \mapsto s[x \mapsto \fc{A}{a}s]$ está bien definida. Pero esto es directo.
    \item[(ii)] Si $S = \n{skip}$, la aplicación asociada es la identidad, que está bien definida. 
\end{itemize}
Los casos inductivos son:
\begin{itemize}
    \item[(i)] Si $S = S_1;S_2$, entonces $\mc{S}_\nn{ds}[[S]] = \mc{S}_\nn{ds}[[S_2]]\circ \mc{S}_\nn{ds}[[S_1]]$, que es composición, por hipótesis de inducción, de funciones bien definidas.
    \item[(ii)] Si $S = \n{if }b \n{ then }S_1 \n{ else }S_2$, de nuevo tenemos que $\mc{S}_\nn{ds}[[S_1]]$ y $\mc{S}_\nn{ds}[[S_2]]$ están bien definidas por hipótesis. Pero es directo comprobar que esto se mantiene por la aplicación $\n{cond}$.
    \item[(iii)] Si $S= \n{while }b \n{ do }S_1$, sabemos que $\mc{S}_\nn{ds}[[S_1]]$ está bien definida. Pero las aplicaciones
    $$F_1(g) := \n{cond}(\fc{B}{b}, g, id), \quad F_2(g) := g \circ \mc{S}_\nn{ds}[[S_1]]$$
    son continuas por los lemas previos. Como sabemos que composición de continuas es continua, tenemos que $F(g) := F_1(F_2(g))$ es continua y, por el Teorema \ref{fixth}, $\n{fix}(F)$ está bien definido, como queríamos ver.
\end{itemize}
\end{proof}

\begin{example} Veamos cómo aplica $\mc{S}_\nn{ds}$ a la sentencia
\[
    S \equiv \n{y}:=\n{1}; \nwhile \neg(\n{x}=1) \ndo (\n{y}:=\n{y}*\n{x}; \n{x}:=\n{x}-\n{1})
\]
y cómo obtener el punto fijo para su bucle. Aplicamos la reglas del sistema denotacional para While (\ref{whileds}) y nos sale
\[
    \mc{S}_\nn{ds}[[S]] s_0 = \n{fix}(F)\ s_0[\n{y} \mapsto \n{1}]
\]
donde
\[
    (F\ g)\ s = \left\{\begin{array}{ll}
         g\ (\mc{S}_\nn{ds}[[\n{y}*\n{x}; \n{x}:=\n{x}-\n{1}]]s) & \fc{B}{\neg(\n{x} = \n{1})}s = \textbf{tt} \\
         s & \fc{B}{\neg(\n{x} = \n{1})}s = \textbf{ff} 
    \end{array}\right.
\]
Aplicando nuevamente las reglas de $\mc{S}_\nn{ds}$ se puede reescribir como
\[
    (F\ g)\ s = \left\{\begin{array}{ll}
         g\ (s[\n{y}\mapsto (s\ \n{y})*(s\ \n{x})][\n{x}\mapsto(s\ \n{x})-\n{1}]) & s\ \n{x} \neq \n{1} \\
         s & s\ \n{x} = \n{1}
    \end{array}\right.
\]
Ahora computamos $F^n\ \bot$ para obtener el menor punto fijo
\begin{eqnarray*}
    (F^0 \bot)\ s &=& \n{INDEFINIDO} \\
    (F^1 \bot)\ s &=& \left\{\begin{array}{ll}
         \n{INDEFINIDO} & s\ \n{x} \neq 1 \\
         s & s\ \n{x} = 1
    \end{array}\right. \\
    (F^2 \bot)\ s &=& \left\{\begin{array}{ll}
         \n{INDEFINIDO} & s\ \n{x} \neq 1 \land s\ \n{x} \neq 2 \\
         s[\n{y}\mapsto (s\ \n{y})*2][x\mapsto 1] & s\ \n{x} = 2 \\
         s & s\ \n{x} = 1
    \end{array}\right. \\
\end{eqnarray*}
Cada evaluación de $F$ representa el cómputo del cuerpo del bucle tantas veces como la condición booleana se cumpla. La fórmula general es
\[
    (F^n \bot)\ s = \left\{\begin{array}{ll}
         \n{INDEFINIDO} & s\ \n{x} < 1 \lor s\ \n{x} > \n{n} \\
         s[\n{y}\mapsto (s\ \n{y})*j*...*2*1][x\mapsto 1] & s\ \n{x} = j \land 1\leq j \land j\leq n \\
    \end{array}\right.
\]
y se tiene que el punto fijo es
\[
    (\n{fix}\ F)\ s = \left\{\begin{array}{ll}
         \n{INDEFINIDO} & s\ \n{x} < 1 \\
         s[\n{y}\mapsto (s\ \n{y})*(s\ \n{x})!][x\mapsto 1] & s\ \n{x}\geq 1 \\
    \end{array}\right.
\]
Si se toma por ejemplo un estado $s_0\in\State$ tal que $s_0\ \n{x} = 3$ se tendría
\[
     (\n{fix}(F)\ s_0[\n{y} \mapsto \n{1}])\ \n{y} = 1*3*2*1 = 6
\]
\end{example}

\begin{example}
Consideremos $\mc{S}_\nn{ds}[[\n{while true do skip}]]$. Tenemos que, $F(g) := \n{cond}(\fc{B}{\n{true}}, g\circ\mc{S}_\nn{ds}[[\n{skip}]], id) =  \n{cond}(\fc{B}{\n{true}}, g\circ id, id) = g$, luego cada aplicación es punto fijo de $F$, y evidentemente, $\bot$ es el menor de todos ellos.

\end{example}
 
\subsection{Equivalencia semántica}

Ahora que ya disponemos de un sistema de semántica denotacional, parece lógico repetirse las mismas preguntas que ya nos hicimos en su momento con la semántica operacional.

\begin{definition}
Dos sentencias $S_1, S_2 \in \mathbf{Stm}$ se dicen \textit{semánticamente equivalentes} si $\mc{S}_\nn{ds}[[S_1]] = \mc{S}_\nn{ds}[[S_2]]$.
\end{definition}

\begin{example} 
EJERCICIO 5.53: Demostrar que los siguientes statements son enquivalentes:
\begin{itemize}
    \item $S; \n{skip  y S}$
    \item $S_1;(S_2;S_3) \n{ y } (S_1; S_2);S_3$ 
    \item $\n{while } b \n{ do } S $ y $\n{if } b \n{ then } (S; \n{while } b \n{ do } S ) \n{ else skip}  $
\end{itemize}
\end{example}

\begin{example}
EJERCICIO 5.54 Demostrar la equivalencia entre $\n{repeat } S \n{ until } b $ y $S; \n{while } \neg b \n{do} S $

$$ \mc{S}_\nn{S}[[ \n{repeat } S \n{ until } b ]] := \n{cond}(\fc{B}{b, \n{skip}}$$

\end{example}


\section{Teorema de equivalencia}

Como siempre, cuando introducimos un nuevo sistema de semántica, nos interesa estudiar si se encuentra relacionado con otros que ya hemos presentado antes. Más concretamente, nos interesa el siguiente enunciado:

\begin{theorem}
Para cada $S \in \mathbf{Stm}$, $\mc{S}_\nn{sos}[[S]] = \mc{S}_\nn{ds}[[S]]$.
\end{theorem}

Notemos que, tanto $\mc{S}_\nn{sos}[[S]]$ como $\mc{S}_\nn{ds}[[S]]$ son elementos de $\mathbf{State}\hookrightarrow\mathbf{State}$, que es un conjunto ordenado por $\sqsubseteq$, luego basta demostrar que $\mc{S}_\nn{sos}[[S]] \sqsubseteq \mc{S}_\nn{ds}[[S]]$ y $\mc{S}_\nn{ds}[[S]] \sqsubseteq \mc{S}_\nn{sos}[[S]]$, para $S \in \mathbf{Stm}$ arbitrario.